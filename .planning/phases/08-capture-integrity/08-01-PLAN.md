---
phase: 08-capture-integrity
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/test_capture_integrity.py
  - src/shitbox/capture/buzzer.py
  - src/shitbox/capture/speaker.py
autonomous: true
requirements:
  - CAPT-01
  - CAPT-02
  - CAPT-03

must_haves:
  truths:
    - "Test file exists with failing tests for all three CAPT requirements before implementation"
    - "buzzer.beep_capture_failed() exists and produces a distinct tone pattern"
    - "speaker.speak_capture_failed() exists and announces the failure via TTS"
  artifacts:
    - path: "tests/test_capture_integrity.py"
      provides: "Unit tests for post-save verification, timelapse gap watchdog, boot save guard"
      min_lines: 100
    - path: "src/shitbox/capture/buzzer.py"
      provides: "beep_capture_failed() function"
      contains: "def beep_capture_failed"
    - path: "src/shitbox/capture/speaker.py"
      provides: "speak_capture_failed() function"
      contains: "def speak_capture_failed"
  key_links:
    - from: "tests/test_capture_integrity.py"
      to: "src/shitbox/capture/ring_buffer.py"
      via: "imports VideoRingBuffer and tests _do_save_event verification"
      pattern: "from shitbox.capture.ring_buffer import VideoRingBuffer"
---

<objective>
Create test scaffolds for all capture integrity behaviours and add the missing
buzzer/speaker alert functions that the implementation plan depends on.

Purpose: Wave 0 — tests must exist before implementation (Nyquist rule) and the
`beep_capture_failed()`/`speak_capture_failed()` functions are called from the
save verification code added in Plan 02. Without them, the import would raise
`AttributeError` inside a background save thread, silently swallowing the callback.

Output: `tests/test_capture_integrity.py` with 10 test functions (all failing until
Plan 02 implements the behaviour), plus two new alert functions in buzzer.py and
speaker.py.
</objective>

<execution_context>
@/Users/tgreen/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tgreen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-capture-integrity/08-RESEARCH.md
@tests/test_ffmpeg_stall.py
@src/shitbox/capture/buzzer.py
@src/shitbox/capture/speaker.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add capture-failed alert functions to buzzer and speaker</name>
  <files>
    src/shitbox/capture/buzzer.py
    src/shitbox/capture/speaker.py
  </files>
  <action>
Add `beep_capture_failed()` to `buzzer.py` following the existing pattern (e.g.
`beep_ffmpeg_stall()`). Use a double-descending tone pattern to distinguish it from
stall alerts: two tones at 440 Hz then 330 Hz, 150 ms each. Check `_should_alert()`
and escalation via `_alert_state.should_escalate()` exactly like the other alert
functions.

Add `speak_capture_failed()` to `speaker.py` following the existing `speak_*()` pattern.
Message: `"Video save failed"`. Guard with `if _voice is None: return` as all other
speak functions do.

Both functions must be importable at module level. No new imports needed — both files
already have all required dependencies.
  </action>
  <verify>
    <automated>cd /Users/tgreen/dev/shitbox && python -c "from shitbox.capture.buzzer import beep_capture_failed; from shitbox.capture.speaker import speak_capture_failed; print('OK')"</automated>
    <manual>Confirm the functions exist and follow the same pattern as their siblings</manual>
  </verify>
  <done>
    beep_capture_failed() and speak_capture_failed() are importable and follow project
    conventions (escalation check, structlog, guard pattern).
  </done>
</task>

<task type="auto">
  <name>Task 2: Create test scaffolds for capture integrity</name>
  <files>tests/test_capture_integrity.py</files>
  <action>
Create `tests/test_capture_integrity.py` using the `_make_vrb()` factory pattern from
`tests/test_ffmpeg_stall.py`. The file must contain these 10 test functions covering
all three CAPT requirements:

**CAPT-01 (post-save verification):**
1. `test_save_verification_missing_file` — Mock `_concatenate_segments` to return a
   Path that does not exist. Assert callback receives `None` and
   `beep_capture_failed` is called.
2. `test_save_verification_zero_byte` — Mock `_concatenate_segments` to return a Path
   pointing to an empty file (0 bytes). Assert callback receives `None`.
3. `test_save_verification_success` — Mock `_concatenate_segments` to return a valid
   Path with non-zero content. Assert callback receives the path.
4. `test_save_verification_failure_alerts` — Mock `_concatenate_segments` to return
   `None`. Assert both `beep_capture_failed` and `speak_capture_failed` are called.

**CAPT-02 (timelapse gap watchdog):**
5. `test_timelapse_gap_detected` — Set `_last_timelapse_time` to a value older than
   `3 * timelapse_interval_seconds` ago, mock speed above threshold, mock
   `capture_frame()` to return `None`. Assert a warning log with
   `timelapse_gap_detected`.
6. `test_timelapse_gap_no_false_positive_at_boot` — Set `_last_timelapse_time = 0.0`
   (sentinel). Assert the gap watchdog does NOT fire even though elapsed is large.
7. `test_timelapse_gap_recovery` — Same setup as test 5 but assert that the ring
   buffer's `_kill_current()` and `_start_ffmpeg()` are called for recovery.

**CAPT-03 (boot guard and partial saves):**
8. `test_boot_save_skipped_no_segments` — Create a mock `video_ring_buffer` with
   `_get_buffer_segments()` returning fewer than 2 segments. Fire a BOOT event via
   `_on_event()`. Assert `save_event()` is NOT called.
9. `test_post_event_empty_segments_logged` — Mock `_copy_complete_segments` to return
   `[]` for post-event copy but non-empty for pre-event. Assert a warning log with
   `video_save_post_event_empty`.
10. `test_partial_save_pre_only` — Same as test 9 but mock `_concatenate_segments` to
    return a valid path. Assert callback receives the valid path (partial save is
    still valid).

Use `unittest.mock.patch` for buzzer/speaker calls. Use `structlog.testing.capture_logs`
or `caplog` for log assertions. Use `tmp_path` fixture for file system operations.

Tests for CAPT-01 and CAPT-03 (ring_buffer changes) should test `_do_save_event()`
directly. Tests for CAPT-02 and CAPT-03 (engine changes) should test
`_check_timelapse()` and `_on_event()` respectively, building a minimal engine mock
or using `patch.object`.

Note: These tests WILL FAIL until Plan 02 implements the corresponding behaviour.
That is correct — they are the RED phase of the TDD cycle.
  </action>
  <verify>
    <automated>cd /Users/tgreen/dev/shitbox && python -c "import tests.test_capture_integrity; print(f'{len([m for m in dir(tests.test_capture_integrity) if m.startswith(\"test_\")])} tests found')"</automated>
    <manual>Verify 10 test functions exist and cover all three requirement IDs</manual>
  </verify>
  <done>
    tests/test_capture_integrity.py exists with 10 test functions. Each CAPT
    requirement has at least 2 tests. Tests use the _make_vrb() factory pattern
    and unittest.mock for isolation.
  </done>
</task>

</tasks>

<verification>
- `python -c "from shitbox.capture.buzzer import beep_capture_failed"` — no ImportError
- `python -c "from shitbox.capture.speaker import speak_capture_failed"` — no ImportError
- `python -c "import tests.test_capture_integrity"` — module imports cleanly
- `ruff check src/shitbox/capture/buzzer.py src/shitbox/capture/speaker.py tests/test_capture_integrity.py` — no lint errors
</verification>

<success_criteria>
- 10 test functions exist covering CAPT-01 (4), CAPT-02 (3), CAPT-03 (3)
- beep_capture_failed() and speak_capture_failed() are importable
- All new code passes ruff check
- Tests are syntactically valid (importable) even if they fail at runtime
</success_criteria>

<output>
After completion, create `.planning/phases/08-capture-integrity/08-01-SUMMARY.md`
</output>
