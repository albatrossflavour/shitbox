---
phase: 02-watchdog-and-self-healing
plan: "02"
type: execute
wave: 2
depends_on:
  - "02-01"
files_modified:
  - src/shitbox/capture/ring_buffer.py
  - tests/test_ffmpeg_stall.py
autonomous: true
requirements:
  - WDOG-03

must_haves:
  truths:
    - "ffmpeg stall is detected when output file mtime stops changing for 30 seconds"
    - "Stall detector does not false-positive when no segments exist yet (startup grace)"
    - "On stall detection, buzzer.beep_ffmpeg_stall() is called, then ffmpeg is killed and restarted"
    - "Stall timer resets on every ffmpeg restart"
  artifacts:
    - path: "src/shitbox/capture/ring_buffer.py"
      provides: "Mtime-based stall detection in _health_monitor"
      contains: "_check_stall"
    - path: "tests/test_ffmpeg_stall.py"
      provides: "Unit tests for stall detection logic"
  key_links:
    - from: "src/shitbox/capture/ring_buffer.py"
      to: "_health_monitor"
      via: "_check_stall() called in health monitor loop"
      pattern: "_check_stall"
    - from: "src/shitbox/capture/ring_buffer.py"
      to: "src/shitbox/capture/buzzer.py"
      via: "beep_ffmpeg_stall() called on stall detection in _health_monitor"
      pattern: "beep_ffmpeg_stall"
---

<objective>
Fix the ffmpeg `is_running` bug by adding mtime-based stall detection to the existing
health monitor in VideoRingBuffer.

Purpose: ffmpeg can be alive but producing no output (process runs but writes nothing to
segment files). The existing health monitor only detects process death via `poll()`. Adding
file mtime monitoring detects frozen output and triggers an automatic restart (WDOG-03).

Output: Stall detection method in ring_buffer.py and comprehensive tests.
</objective>

<execution_context>
@/Users/tgreen/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tgreen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-watchdog-and-self-healing/02-RESEARCH.md
@.planning/phases/02-watchdog-and-self-healing/02-01-SUMMARY.md
@src/shitbox/capture/ring_buffer.py
@src/shitbox/capture/buzzer.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add mtime-based stall detection to VideoRingBuffer health monitor</name>
  <files>
    src/shitbox/capture/ring_buffer.py
  </files>
  <action>
Add stall detection to `VideoRingBuffer`:

1. Add class constant `STALL_TIMEOUT_SECONDS = 30` (conservative for 10-second segments)

2. Add instance variables in `__init__`:
   - `self._last_segment_mtime: float = 0.0`
   - `self._last_segment_size: int = 0`
   - `self._stall_check_armed: bool = False` (arms after first segment appears)

3. Add `_reset_stall_state(self) -> None` method:
   - Sets `_last_segment_mtime = 0.0`, `_last_segment_size = 0`, `_stall_check_armed = False`
   - Called from `_start_ffmpeg()` at the start, before launching the process

4. Add `_check_stall(self) -> bool` method:
   - Call `self._get_buffer_segments()` to get current segments
   - If no segments: return False (ffmpeg still starting up)
   - Get the newest segment (segments[-1])
   - `stat()` the newest segment; if OSError, return False
   - If not yet armed (`_stall_check_armed` is False):
     - Set `_stall_check_armed = True`
     - Record `_last_segment_mtime` and `_last_segment_size`
     - Return False (first observation, no baseline to compare)
   - If `st.st_mtime != self._last_segment_mtime` or `st.st_size != self._last_segment_size`:
     - Update `_last_segment_mtime` and `_last_segment_size`
     - Return False (activity detected)
   - Else: return `(time.time() - self._last_segment_mtime) > self.STALL_TIMEOUT_SECONDS`

5. Modify `_health_monitor()`:
   - After the existing crash detection block (`if self._process is not None and self._process.poll() is not None`),
     add a stall detection block:
     ```python
     if self._check_stall():
         log.warning("ffmpeg_stall_detected",
                     timeout_seconds=self.STALL_TIMEOUT_SECONDS)
         from shitbox.capture import buzzer
         buzzer.beep_ffmpeg_stall()
         self._kill_current()
         self._start_ffmpeg()
         continue
     ```

6. Modify `_start_ffmpeg()`:
   - Call `self._reset_stall_state()` at the very beginning of the method (before mkdir)
     so the stall timer resets on every restart

Full type annotations required. Use structlog keyword arguments for all log messages.
  </action>
  <verify>
    <automated>ruff check src/shitbox/capture/ring_buffer.py &amp;&amp; python -c "from shitbox.capture.ring_buffer import VideoRingBuffer; v = VideoRingBuffer.__new__(VideoRingBuffer); assert hasattr(v, '_check_stall') or hasattr(VideoRingBuffer, '_check_stall')"</automated>
  </verify>
  <done>
    VideoRingBuffer has _check_stall() method, STALL_TIMEOUT_SECONDS constant, stall state
    reset on ffmpeg restart, and stall detection wired into _health_monitor loop
  </done>
</task>

<task type="auto">
  <name>Task 2: Tests for ffmpeg stall detection</name>
  <files>
    tests/test_ffmpeg_stall.py
  </files>
  <action>
Create `tests/test_ffmpeg_stall.py` with unit tests for the stall detection logic.
Use `tmp_path` fixture for segment files and mock/patch where needed.

1. **Helper:** Create a factory function that builds a `VideoRingBuffer` with `buffer_dir`
   set to `tmp_path / "buffer"` and creates that directory. Do NOT call `start()` or
   `_start_ffmpeg()` — test the detection method directly.

2. `test_stall_not_detected_on_activity`:
   - Create segment files in buffer_dir (e.g. `seg_000.ts`, `seg_001.ts`) with content
   - Call `_check_stall()` — first call arms the detector, returns False
   - Modify the newest segment file (append bytes to change size/mtime)
   - Call `_check_stall()` again — returns False (activity detected)

3. `test_stall_detected_after_timeout`:
   - Create segment files in buffer_dir
   - Call `_check_stall()` to arm
   - Call `_check_stall()` again (same mtime/size) — but mtime is recent so returns False
   - Monkeypatch `time.time` to return `segment_mtime + STALL_TIMEOUT_SECONDS + 1`
   - Call `_check_stall()` again — returns True

4. `test_stall_not_triggered_before_first_segment`:
   - Create VideoRingBuffer with empty buffer_dir (no segments)
   - Call `_check_stall()` — returns False
   - Confirm `_stall_check_armed` is still False

5. `test_stall_arms_on_first_segment`:
   - Create VideoRingBuffer with empty buffer_dir
   - Call `_check_stall()` — False, not armed
   - Create a segment file
   - Call `_check_stall()` — False (arms, records baseline)
   - Confirm `_stall_check_armed` is True

6. `test_stall_state_resets`:
   - Create VideoRingBuffer, create segments, call `_check_stall()` to arm
   - Call `_reset_stall_state()`
   - Confirm `_stall_check_armed` is False, `_last_segment_mtime` is 0.0

7. `test_health_monitor_restarts_on_stall` (integration-style):
   - Create VideoRingBuffer, patch `_check_stall` to return True
   - Patch `_kill_current` and `_start_ffmpeg` as mocks
   - Patch `buzzer.beep_ffmpeg_stall` as a mock
   - Patch `_process` to have `poll()` return None (process alive)
   - Set `_running = True`, run one iteration of `_health_monitor` logic
     (or set `_running` to False after a short sleep to stop the loop)
   - Assert `buzzer.beep_ffmpeg_stall` called once
   - Assert `_kill_current` called once, `_start_ffmpeg` called once

Use `time.sleep(0.01)` where needed to ensure mtime differs between file operations.
  </action>
  <verify>
    <automated>pytest tests/test_ffmpeg_stall.py -x -q</automated>
  </verify>
  <done>
    All stall detection tests pass: activity detection, timeout detection, startup grace,
    arming, state reset, and health monitor integration
  </done>
</task>

</tasks>

<verification>
- `ruff check src/shitbox/capture/ring_buffer.py` passes
- `pytest tests/test_ffmpeg_stall.py -x -q` all pass
- `grep -c "_check_stall" src/shitbox/capture/ring_buffer.py` returns at least 2 (definition + call)
- `grep -c "STALL_TIMEOUT_SECONDS" src/shitbox/capture/ring_buffer.py` returns at least 1
</verification>

<success_criteria>
- VideoRingBuffer detects stalled ffmpeg via file mtime monitoring
- Stall detector does not false-positive on startup (no segments yet)
- Stall state resets on every ffmpeg restart
- Health monitor kills and restarts ffmpeg on stall detection
- All tests green
</success_criteria>

<output>
After completion, create `.planning/phases/02-watchdog-and-self-healing/02-02-SUMMARY.md`
</output>
