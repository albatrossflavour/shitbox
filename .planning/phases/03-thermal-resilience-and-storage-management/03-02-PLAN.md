---
phase: 03-thermal-resilience-and-storage-management
plan: 02
type: execute
wave: 2
depends_on:
  - 03-01
files_modified:
  - src/shitbox/health/thermal_monitor.py
  - src/shitbox/events/engine.py
autonomous: true
requirements:
  - THRM-01
  - THRM-02
  - THRM-03
  - STOR-01

must_haves:
  truths:
    - "CPU temperature is sampled every 5 seconds and available via current_temp_celsius property"
    - "Buzzer alerts at 70C warning and 80C critical with 3C hysteresis"
    - "Recovery beep fires when temperature drops below 67C after a warning"
    - "Throttle state decoded and logged only on bitmask change"
    - "Under-voltage (bit 0) triggers distinct buzzer alert"
    - "WAL TRUNCATE checkpoint runs every 5 minutes from telemetry loop"
    - "ThermalMonitorService starts and stops with engine lifecycle"
  artifacts:
    - path: "src/shitbox/health/thermal_monitor.py"
      provides: "ThermalMonitorService with hysteresis state machine and throttle decode"
      exports: ["ThermalMonitorService"]
      min_lines: 100
    - path: "src/shitbox/events/engine.py"
      provides: "Engine wiring for thermal monitor and WAL checkpoint timer"
      contains: "thermal_monitor"
  key_links:
    - from: "src/shitbox/health/thermal_monitor.py"
      to: "src/shitbox/capture/buzzer.py"
      via: "import and call beep_thermal_warning/critical/under_voltage/recovered"
      pattern: "buzzer\\.beep_thermal"
    - from: "src/shitbox/health/thermal_monitor.py"
      to: "/sys/class/thermal/thermal_zone0/temp"
      via: "pathlib read_text"
      pattern: "thermal_zone0"
    - from: "src/shitbox/health/thermal_monitor.py"
      to: "vcgencmd"
      via: "subprocess.run"
      pattern: "vcgencmd.*get_throttled"
    - from: "src/shitbox/events/engine.py"
      to: "src/shitbox/health/thermal_monitor.py"
      via: "import and start/stop lifecycle"
      pattern: "thermal_monitor\\.start|thermal_monitor\\.stop"
    - from: "src/shitbox/events/engine.py"
      to: "src/shitbox/storage/database.py"
      via: "checkpoint_wal call on 5-minute timer"
      pattern: "checkpoint_wal"
---

<objective>
Implement ThermalMonitorService as a daemon thread with 5-second cadence that reads CPU
temperature from sysfs, decodes vcgencmd throttle bitmask, fires buzzer alerts at threshold
crossings with hysteresis, and publishes temperature to a thread-safe shared value. Wire it
into UnifiedEngine lifecycle and add a 5-minute WAL checkpoint timer to the telemetry loop.

Purpose: This is the core implementation that satisfies all four Phase 3 requirements. The
thermal monitor gives the driver audible warning before thermal throttle degrades IMU sampling,
and the WAL checkpoint prevents the SD card from accumulating unbounded WAL data.

Output: Working ThermalMonitorService, engine integration, all Phase 3 tests passing.
</objective>

<execution_context>
@/Users/tgreen/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tgreen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-thermal-resilience-and-storage-management/03-CONTEXT.md
@.planning/phases/03-thermal-resilience-and-storage-management/03-RESEARCH.md
@.planning/phases/03-thermal-resilience-and-storage-management/03-01-SUMMARY.md
@src/shitbox/capture/buzzer.py
@src/shitbox/storage/database.py
@src/shitbox/events/engine.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement ThermalMonitorService</name>
  <files>src/shitbox/health/thermal_monitor.py</files>
  <action>
Create `src/shitbox/health/thermal_monitor.py` following the BatchSyncService/CaptureSyncService daemon thread pattern from the codebase.

**Module-level constants:**
- `TEMP_WARNING_C = 70.0`
- `TEMP_CRITICAL_C = 80.0`
- `HYSTERESIS_C = 3.0`
- `POLL_INTERVAL_S = 5.0`

**Module-level functions (not methods — easier to mock in tests):**
- `_read_sysfs_temp() -> float | None`: Read `/sys/class/thermal/thermal_zone0/temp`, divide by 1000.0. Catch IOError and ValueError, return None on failure. Use `pathlib.Path`.
- `_read_throttled() -> int | None`: Run `subprocess.run(["vcgencmd", "get_throttled"], capture_output=True, text=True, timeout=2)`. Parse `"throttled=0xNNNN"` output. Catch FileNotFoundError, TimeoutExpired, ValueError — return None.
- `_decode_throttled(value: int) -> dict`: Decode bitmask into `{"current": {...}, "since_boot": {...}}` using the documented Pi firmware bit layout (bits 0-3 for current, bits 16-19 for since-boot). Use dict comprehensions against named flag dicts.

**Throttle flag dicts (module-level):**
```python
THROTTLE_FLAGS = {0: "under_voltage", 1: "freq_capped", 2: "throttled", 3: "soft_temp_limit"}
BOOT_THROTTLE_FLAGS = {16: "under_voltage_since_boot", 17: "freq_capped_since_boot", 18: "throttled_since_boot", 19: "soft_temp_limit_since_boot"}
```

**ThermalMonitorService class:**
- `__init__()`: Set `_thread = None`, `_running = False`, `_lock = threading.Lock()`, `_current_temp: float | None = None`, `_warning_armed = True`, `_critical_armed = True`, `_last_throttled_raw: int | None = None`.
- `current_temp_celsius` property: Thread-safe read with `_lock`.
- `start()`: Create daemon thread targeting `_loop`, name `"thermal-monitor"`, set `_running = True`, start thread, log `"thermal_monitor_started"`.
- `stop()`: Set `_running = False`, join thread with `timeout=POLL_INTERVAL_S + 1`, log `"thermal_monitor_stopped"`.
- `_loop()`: While `_running`: try `_check_thermal()`, except log error, sleep `POLL_INTERVAL_S`.
- `_check_thermal()`:
  1. Read temp via `_read_sysfs_temp()`. If None, return early.
  2. Update `_current_temp` under lock.
  3. Warning threshold (70C): If `temp >= TEMP_WARNING_C and _warning_armed` → log warning with `temp_celsius=round(temp, 1)` and `threshold=TEMP_WARNING_C`, call `buzzer.beep_thermal_warning()`, set `_warning_armed = False`.
  4. Warning recovery: If `temp < (TEMP_WARNING_C - HYSTERESIS_C)` and `not _warning_armed` → log info `"cpu_temp_recovered"`, call `buzzer.beep_thermal_recovered()`, set `_warning_armed = True`.
  5. Critical threshold (80C): If `temp >= TEMP_CRITICAL_C and _critical_armed` → log error with `temp_celsius` and `threshold=TEMP_CRITICAL_C`, call `buzzer.beep_thermal_critical()`, set `_critical_armed = False`.
  6. Critical recovery: If `temp < (TEMP_CRITICAL_C - HYSTERESIS_C)` → set `_critical_armed = True` (silent, no beep).
  7. Call `_check_throttled()`.
- `_check_throttled()`:
  1. Read via `_read_throttled()`. If None, return.
  2. If `raw == _last_throttled_raw`, return (no change, silent).
  3. Update `_last_throttled_raw = raw`.
  4. Decode via `_decode_throttled(raw)`.
  5. Log `"throttle_state_changed"` with `raw_hex=hex(raw)`, `current=decoded["current"]`, `since_boot=decoded["since_boot"]`.
  6. If `decoded["current"]["under_voltage"]` is True, call `buzzer.beep_under_voltage()`.

**Import buzzer lazily** inside `_check_thermal` and `_check_throttled` methods (import at top of method body: `from shitbox.capture import buzzer`) to avoid circular imports, same pattern as Phase 2 stall detection. Alternatively, import at module level if no circular dependency exists — check engine.py imports first.

**Type annotations** on all functions and methods. Use `from __future__ import annotations` for Python 3.9 compatibility with `float | None` syntax.
  </action>
  <verify>
    <automated>cd /Users/tgreen/dev/shitbox && pytest tests/test_thermal_monitor.py -x -q && ruff check src/shitbox/health/thermal_monitor.py && mypy src/shitbox/health/thermal_monitor.py --ignore-missing-imports</automated>
  </verify>
  <done>All 9 thermal monitor tests pass. ThermalMonitorService reads temperature, fires alerts with hysteresis, decodes throttle state, and publishes temp via thread-safe property.</done>
</task>

<task type="auto">
  <name>Task 2: Wire ThermalMonitorService and WAL checkpoint into engine</name>
  <files>src/shitbox/events/engine.py</files>
  <action>
Wire ThermalMonitorService and periodic WAL checkpoint into UnifiedEngine. Follow the exact pattern used for boot_recovery, batch_sync, and capture_sync services.

1. **Import** at top of engine.py:
   ```python
   from shitbox.health.thermal_monitor import ThermalMonitorService
   ```

2. **EngineConfig**: No new config fields needed — thresholds are hardcoded per user decision.

3. **UnifiedEngine.__init__()**: Add `self.thermal_monitor = ThermalMonitorService()`. Add `self._last_wal_checkpoint: float = 0.0` for the WAL checkpoint timer. Add constant `WAL_CHECKPOINT_INTERVAL_S = 300.0` (5 minutes) at module level or as class attribute.

4. **UnifiedEngine.start()**: Add `self.thermal_monitor.start()` after existing service starts (after boot recovery, alongside or after batch_sync/capture_sync). Log is already handled by ThermalMonitorService.start().

5. **UnifiedEngine.stop()**: Add `self.thermal_monitor.stop()` alongside other service stops.

6. **_telemetry_loop()** (or wherever the periodic timer runs): Add WAL checkpoint timer logic:
   ```python
   now = time.monotonic()  # or whatever time source the loop uses
   if (now - self._last_wal_checkpoint) >= WAL_CHECKPOINT_INTERVAL_S:
       try:
           self.database.checkpoint_wal()
       except Exception as e:
           log.error("wal_checkpoint_error", error=str(e))
       self._last_wal_checkpoint = now
   ```
   Place this alongside the existing periodic cleanup/maintenance code in the telemetry loop. Use the same time source (`time.monotonic()` or `time.time()`) as other timers in the loop.

7. **get_status()**: Update to read temperature from thermal_monitor instead of calling `_read_pi_temp()` directly:
   ```python
   "cpu_temp": self.thermal_monitor.current_temp_celsius,
   ```
   This replaces the existing `_read_pi_temp()` call in get_status (if present). Keep `_read_pi_temp()` method for backward compatibility but the thermal monitor is now the single source.

8. **Do NOT** create a new thread for WAL checkpoint — it runs on the existing telemetry loop timer, per user decision.
  </action>
  <verify>
    <automated>cd /Users/tgreen/dev/shitbox && pytest tests/ -x -q && ruff check src/shitbox/events/engine.py && mypy src/shitbox/events/engine.py --ignore-missing-imports</automated>
    <manual>Verify in engine.py that thermal_monitor.start() is called in start(), thermal_monitor.stop() in stop(), and checkpoint_wal() is called on a 5-minute timer in the telemetry loop</manual>
  </verify>
  <done>ThermalMonitorService starts/stops with engine. WAL checkpoint runs every 5 minutes from telemetry loop. get_status() reads temperature from thermal_monitor. All existing tests still pass.</done>
</task>

</tasks>

<verification>
- `pytest tests/ -x -q` — full test suite passes
- `pytest tests/test_thermal_monitor.py -x -q` — all 9 thermal monitor tests pass
- `pytest tests/test_buzzer_alerts.py -x -q` — all buzzer tests pass (including thermal patterns from Plan 01)
- `pytest tests/test_database.py -x -q` — all database tests pass (including checkpoint_wal from Plan 01)
- `ruff check src/` — no lint errors
- `mypy src/shitbox/health/thermal_monitor.py --ignore-missing-imports` — no type errors
</verification>

<success_criteria>
- ThermalMonitorService reads CPU temperature every 5 seconds from sysfs
- Temperature available via thread-safe current_temp_celsius property
- Warning buzzer at 70C, critical at 80C, with 3C hysteresis on both
- Recovery beep when temp drops below 67C after warning
- vcgencmd get_throttled decoded and logged on state change only
- Under-voltage (bit 0) triggers distinct buzzer alert
- WAL TRUNCATE checkpoint runs every 5 minutes from engine telemetry loop
- ThermalMonitorService wired into engine start/stop lifecycle
- get_status() reads from thermal_monitor.current_temp_celsius
- All tests pass, no lint or type errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-thermal-resilience-and-storage-management/03-02-SUMMARY.md`
</output>
