---
phase: 03-thermal-resilience-and-storage-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/shitbox/capture/buzzer.py
  - src/shitbox/storage/database.py
  - src/shitbox/health/__init__.py
  - tests/test_thermal_monitor.py
  - tests/test_buzzer_alerts.py
  - tests/test_database.py
autonomous: true
requirements:
  - THRM-02
  - STOR-01

must_haves:
  truths:
    - "Four new buzzer functions exist for thermal alerts (warning, critical, under_voltage, recovered)"
    - "Database.checkpoint_wal() runs TRUNCATE and logs only when pages were checkpointed"
    - "Test scaffolds exist for all THRM and STOR requirements before implementation begins"
  artifacts:
    - path: "src/shitbox/health/__init__.py"
      provides: "Empty init for health package"
    - path: "src/shitbox/capture/buzzer.py"
      provides: "beep_thermal_warning, beep_thermal_critical, beep_under_voltage, beep_thermal_recovered"
    - path: "src/shitbox/storage/database.py"
      provides: "checkpoint_wal() method"
      contains: "wal_checkpoint"
    - path: "tests/test_thermal_monitor.py"
      provides: "Test scaffold for ThermalMonitorService"
    - path: "tests/test_buzzer_alerts.py"
      provides: "Tests for thermal buzzer patterns"
    - path: "tests/test_database.py"
      provides: "Tests for checkpoint_wal"
  key_links:
    - from: "src/shitbox/storage/database.py"
      to: "sqlite3"
      via: "PRAGMA wal_checkpoint(TRUNCATE)"
      pattern: "wal_checkpoint\\(TRUNCATE\\)"
    - from: "src/shitbox/capture/buzzer.py"
      to: "_play_async"
      via: "thermal alert functions calling _play_async"
      pattern: "beep_thermal_warning|beep_thermal_critical|beep_under_voltage|beep_thermal_recovered"
---

<objective>
Create test scaffolds for all Phase 3 requirements, add four thermal buzzer alert functions,
add WAL checkpoint method to Database, and create the health package directory.

Purpose: Establishes the test-first foundation and small additions to existing modules that
Plan 02 depends on (buzzer functions called by ThermalMonitorService, checkpoint_wal called
from engine telemetry loop).

Output: Test files with failing tests, buzzer.py with thermal alerts, database.py with
checkpoint_wal(), empty health/__init__.py package.
</objective>

<execution_context>
@/Users/tgreen/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tgreen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-thermal-resilience-and-storage-management/03-CONTEXT.md
@.planning/phases/03-thermal-resilience-and-storage-management/03-RESEARCH.md
@src/shitbox/capture/buzzer.py
@src/shitbox/storage/database.py
@tests/test_buzzer_alerts.py
@tests/test_database.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add thermal buzzer functions, WAL checkpoint, and health package</name>
  <files>
    src/shitbox/health/__init__.py
    src/shitbox/capture/buzzer.py
    src/shitbox/storage/database.py
  </files>
  <action>
1. Create `src/shitbox/health/__init__.py` as an empty file (just a docstring: "Health monitoring services.").

2. Add four new functions to `src/shitbox/capture/buzzer.py` at the end of the file, following the exact pattern of `beep_service_crash()` and other existing alert functions:
   - `beep_thermal_warning()`: Two 500 Hz tones at 400 ms each. Check `_should_alert()` first; use `_alert_state.should_escalate("buzzer-thermal-warning")` for escalation (double pattern). Docstring: "Two medium 500 Hz tones: CPU temperature at warning threshold (70C)."
   - `beep_thermal_critical()`: Three 500 Hz tones at 600 ms each. Same guard pattern. Escalation key: "buzzer-thermal-critical". Docstring: "Three long 500 Hz tones: CPU temperature at critical threshold (80C)."
   - `beep_under_voltage()`: Four rapid 500 Hz tones at 150 ms each. Escalation key: "buzzer-under-voltage". Docstring: "Four rapid 500 Hz tones: under-voltage detected."
   - `beep_thermal_recovered()`: Descending pair `[(880, 150), (500, 150)]`. NO escalation check — instead call `_alert_state.reset("buzzer-thermal-warning")` before playing. Docstring: "Descending pair: temperature recovered below warning threshold."

   All four functions are suppressed during boot grace period (via `_should_alert()`). Use 500 Hz frequency to distinguish from service-failure alerts (330 Hz) per RESEARCH.md.

3. Add `checkpoint_wal()` method to `Database` class in `src/shitbox/storage/database.py`:
   - Uses `self._get_connection()` to get the thread-local connection
   - Acquires `self._write_lock` (existing lock) for the PRAGMA call
   - Executes `PRAGMA wal_checkpoint(TRUNCATE)`
   - Fetches the result row `(busy, log, checkpointed)`
   - Logs with structlog ONLY when `row[2] > 0` (pages actually checkpointed): `log.info("wal_checkpoint_completed", pages_checkpointed=row[2], pages_in_wal=row[1])`
   - Silent when WAL was already clean (row[2] == 0)
   - Place the method after the existing `close()` method
  </action>
  <verify>
    <automated>cd /Users/tgreen/dev/shitbox && python -c "from shitbox.capture.buzzer import beep_thermal_warning, beep_thermal_critical, beep_under_voltage, beep_thermal_recovered; print('buzzer OK')" && python -c "from shitbox.storage.database import Database; assert hasattr(Database, 'checkpoint_wal'); print('database OK')" && python -c "import shitbox.health; print('health package OK')"</automated>
  </verify>
  <done>Four thermal buzzer functions importable, checkpoint_wal method exists on Database, health package importable</done>
</task>

<task type="auto">
  <name>Task 2: Create test scaffolds for all Phase 3 requirements</name>
  <files>
    tests/test_thermal_monitor.py
    tests/test_buzzer_alerts.py
    tests/test_database.py
  </files>
  <action>
1. Create `tests/test_thermal_monitor.py` with the following tests (all should pass once Plan 02 implements ThermalMonitorService, but the tests that exercise buzzer functions from Task 1 can pass now with mocks):

   - `test_temp_published_to_shared_state` (THRM-01): Mock sysfs read to return 55000 (55C). Create ThermalMonitorService, call `_check_thermal()` directly. Assert `current_temp_celsius == 55.0`.
   - `test_temp_thread_safe` (THRM-01): Spawn 10 threads reading `current_temp_celsius` while another writes. Assert no exceptions.
   - `test_warning_fires_at_threshold` (THRM-02): Mock sysfs to return 70000 (70C). Call `_check_thermal()`. Assert buzzer `beep_thermal_warning` was called.
   - `test_hysteresis_suppresses_below_rearm` (THRM-02): Set temp to 70C (fires), then 69C (still suppressed), then 66C (re-arms), then 70C again (fires again). Assert buzzer called exactly twice.
   - `test_critical_fires_independently` (THRM-02): Set temp to 80C with warning already disarmed. Assert `beep_thermal_critical` called but not `beep_thermal_warning` (already disarmed).
   - `test_recovery_beep_on_cooldown` (THRM-02): Fire warning at 70C, then cool to 66C. Assert `beep_thermal_recovered` called.
   - `test_throttle_logs_only_on_change` (THRM-03): Call `_check_throttled()` twice with same bitmask. Assert log emitted only once.
   - `test_under_voltage_triggers_buzzer` (THRM-03): Set throttle bitmask with bit 0 set. Assert `beep_under_voltage` called.
   - `test_vcgencmd_not_found_graceful` (THRM-03): Mock subprocess.run to raise FileNotFoundError. Assert `_read_throttled()` returns None, no exception.

   Use `@patch` for sysfs reads (mock `Path.read_text` or the `_read_sysfs_temp` function) and `@patch` for buzzer functions. Import from `shitbox.health.thermal_monitor`. Tests will initially fail (import error) until Plan 02 creates the module — this is expected and correct for Wave 0 scaffolding.

2. Add thermal buzzer pattern tests to `tests/test_buzzer_alerts.py` (these CAN pass now since Task 1 adds the functions):
   - `test_beep_thermal_warning_pattern`: Mock `_buzzer` and `_play_async`, set boot time far in past, call `beep_thermal_warning()`. Assert `_play_async` called with `[(500, 400), (500, 400)]`.
   - `test_beep_thermal_critical_pattern`: Assert called with `[(500, 600), (500, 600), (500, 600)]`.
   - `test_beep_under_voltage_pattern`: Assert called with `[(500, 150), (500, 150), (500, 150), (500, 150)]`.
   - `test_beep_thermal_recovered_pattern`: Assert called with `[(880, 150), (500, 150)]` and that `_alert_state.reset` was called with `"buzzer-thermal-warning"`.

   Follow the exact test pattern used by existing tests in this file (mock `_buzzer`, patch `_play_async`, set `_boot_start_time` far in past).

3. Add WAL checkpoint tests to `tests/test_database.py`:
   - `test_checkpoint_wal_logs_when_dirty` (STOR-01): Create Database, connect, insert a row (to dirty WAL), call `checkpoint_wal()`. Patch structlog and assert `log.info` called with `"wal_checkpoint_completed"`.
   - `test_checkpoint_wal_silent_when_clean` (STOR-01): Create Database, connect, call `checkpoint_wal()` on a fresh DB with no writes. Assert `log.info` NOT called with `"wal_checkpoint_completed"`.
  </action>
  <verify>
    <automated>cd /Users/tgreen/dev/shitbox && pytest tests/test_buzzer_alerts.py -x -q && pytest tests/test_database.py -x -q</automated>
    <manual>test_thermal_monitor.py tests will fail with ImportError until Plan 02 — that is expected</manual>
  </verify>
  <done>Buzzer alert tests and database checkpoint tests pass. Thermal monitor tests exist as scaffolds (will pass after Plan 02).</done>
</task>

</tasks>

<verification>
- `pytest tests/test_buzzer_alerts.py -x -q` passes (including new thermal pattern tests)
- `pytest tests/test_database.py -x -q` passes (including new checkpoint_wal tests)
- `python -c "from shitbox.capture.buzzer import beep_thermal_warning"` succeeds
- `python -c "from shitbox.storage.database import Database; assert hasattr(Database, 'checkpoint_wal')"` succeeds
- `python -c "import shitbox.health"` succeeds
- `ruff check src/shitbox/capture/buzzer.py src/shitbox/storage/database.py src/shitbox/health/__init__.py` clean
</verification>

<success_criteria>
- Four thermal buzzer functions are importable and follow the established _should_alert / _play_async pattern
- Database.checkpoint_wal() method exists and logs conditionally
- health package created with empty __init__.py
- All buzzer alert tests pass (existing + new thermal patterns)
- All database tests pass (existing + new checkpoint_wal tests)
- Thermal monitor test scaffold exists (expected to fail until Plan 02)
</success_criteria>

<output>
After completion, create `.planning/phases/03-thermal-resilience-and-storage-management/03-01-SUMMARY.md`
</output>
