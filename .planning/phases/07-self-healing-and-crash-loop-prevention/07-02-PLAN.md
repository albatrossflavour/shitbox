---
phase: 07-self-healing-and-crash-loop-prevention
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/shitbox/events/engine.py
  - tests/test_speaker_alerts.py
autonomous: true
requirements:
  - HEAL-01
  - HEAL-03

must_haves:
  truths:
    - "When the TTS speaker worker thread dies, the health check detects it within 30 seconds and re-initialises the speaker"
    - "Speaker re-initialisation is not attempted when the speaker was never initialised (_voice is None)"
    - "After any successful health-check recovery (IMU, video, GPS, speaker), a TTS recovery confirmation is announced"
    - "After any successful health-check recovery, the buzzer plays the service_recovered tone"
  artifacts:
    - path: "src/shitbox/events/engine.py"
      provides: "Speaker watchdog in _health_check and recovery confirmation announcements"
      contains: "speaker_worker_dead"
    - path: "tests/test_speaker_alerts.py"
      provides: "Unit tests for speaker watchdog and recovery announcements"
      min_lines: 200
  key_links:
    - from: "src/shitbox/events/engine.py"
      to: "shitbox.capture.speaker"
      via: "_health_check speaker worker liveness check"
      pattern: "_worker.is_alive"
    - from: "src/shitbox/events/engine.py"
      to: "buzzer.beep_service_recovered"
      via: "recovery confirmation after health_check_recovered"
      pattern: "beep_service_recovered"
---

<objective>
Add speaker worker watchdog to the engine health check and wire recovery confirmation
announcements (TTS + buzzer) after every successful subsystem recovery, completing the
detect-alert-recover-escalate pattern across all subsystems.

Purpose: The TTS speaker worker thread can silently die from a Piper exception or USB
disconnect, leaving all `speak_*()` calls enqueuing to a dead queue. The health check
already runs every 30 seconds — adding the speaker liveness check satisfies HEAL-01's
detection requirement. Recovery confirmations (HEAL-03) ensure the driver hears when
the system has self-healed.

Output: Modified engine.py with speaker watchdog and recovery announcements, plus
comprehensive unit tests.
</objective>

<execution_context>
@/Users/tgreen/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tgreen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-self-healing-and-crash-loop-prevention/07-RESEARCH.md
@src/shitbox/events/engine.py
@src/shitbox/capture/speaker.py
@tests/test_speaker_alerts.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add speaker watchdog and recovery confirmations to health check</name>
  <files>src/shitbox/events/engine.py</files>
  <action>
Modify `_health_check()` in `UnifiedEngine` to add two new behaviours:

**Speaker worker watchdog (after check 5, before alarm logic):**

Add a new numbered check "6. Speaker worker health" after the disk space check:

```python
# 6. Speaker worker health (HEAL-01)
if self.config.speaker_enabled:
    if (
        speaker._voice is not None
        and speaker._worker is not None
        and not speaker._worker.is_alive()
    ):
        log.warning("speaker_worker_dead", restarting=True)
        issues.append("speaker_worker_dead")
        try:
            speaker.cleanup()
            if speaker.init(self.config.speaker_model_path):
                recovered.append("speaker")
                log.info("speaker_reinitialised")
            else:
                log.error("speaker_reinit_failed_no_device")
        except Exception as e:
            log.error("speaker_reinit_exception", error=str(e))
```

IMPORTANT guards per research Pitfall 2 and 6:
- Only trigger when `_voice is not None` (speaker was previously working).
- Only trigger when `_worker is not None` (avoid AttributeError after cleanup).
- Only trigger when `not _worker.is_alive()` (thread specifically died).
- Do NOT attempt reinit when `_voice is None` — speaker was never initialised.
- Call `cleanup()` before `init()` — never call `init()` without `cleanup()` first (Pitfall 5).

The `speaker` module is already imported at module level in engine.py (`from shitbox.capture import buzzer, overlay, speaker`).

**Recovery confirmation announcements (HEAL-03):**

In the existing `if recovered:` block at the end of `_health_check()` (currently just logs), add:

```python
if recovered:
    log.info("health_check_recovered", subsystems=recovered)
    buzzer.beep_service_recovered("subsystem")
    speaker.speak_service_recovered()
```

This ensures the driver hears a confirmation after ANY successful recovery (IMU, telemetry, video, GPS, or speaker).
  </action>
  <verify>
    <automated>cd /Users/tgreen/dev/shitbox && ruff check src/shitbox/events/engine.py</automated>
  </verify>
  <done>Health check includes speaker worker liveness detection and reinitialisation. All subsystem recoveries are announced via TTS and buzzer.</done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests for speaker watchdog and recovery announcements</name>
  <files>tests/test_speaker_alerts.py</files>
  <action>
Add new test functions to the existing `tests/test_speaker_alerts.py` file. Follow the existing test patterns in that file (mocked speaker module, mocked engine).

Tests to add:

1. `test_health_check_detects_dead_speaker_worker` — Set up engine with `speaker_enabled=True`. Mock `speaker._voice` as non-None, `speaker._worker` as a mock with `is_alive()` returning False. Call `_health_check()`. Verify `speaker.cleanup()` was called, then `speaker.init()` was called with the model path.

2. `test_health_check_speaker_reinit_success_adds_recovered` — Same setup as test 1 but mock `speaker.init()` to return True. Verify "speaker" is in the recovered list (check the `health_check_recovered` log event or verify `speak_service_recovered()` was called).

3. `test_health_check_speaker_reinit_failure_logged` — Mock `speaker.init()` to return False. Verify `speaker_reinit_failed_no_device` is logged and "speaker" is NOT added to recovered.

4. `test_health_check_skips_speaker_when_never_initialised` — Set `speaker._voice = None`. Call `_health_check()`. Verify `speaker.cleanup()` is NOT called (no reinit attempted when speaker was never initialised).

5. `test_health_check_skips_speaker_when_worker_none` — Set `speaker._voice` as non-None but `speaker._worker = None`. Call `_health_check()`. Verify no AttributeError and `speaker.cleanup()` is NOT called.

6. `test_health_check_recovery_announces_via_tts` — Simulate any subsystem recovery (e.g. mock telemetry thread as dead, let health check restart it). Verify `speaker.speak_service_recovered()` is called after the recovery.

7. `test_health_check_recovery_announces_via_buzzer` — Same as test 6 but verify `buzzer.beep_service_recovered()` is called with argument "subsystem".

8. `test_health_check_no_announcement_when_no_recovery` — All subsystems healthy. Verify `speak_service_recovered()` and `beep_service_recovered()` are NOT called.

Follow the existing pattern in the test file for creating a minimal engine config and mocking subsystems. Use `unittest.mock.patch` for speaker module-level state.
  </action>
  <verify>
    <automated>cd /Users/tgreen/dev/shitbox && pytest tests/test_speaker_alerts.py -x -q</automated>
  </verify>
  <done>All existing speaker tests pass. 8 new tests cover dead worker detection, reinitialisation success/failure, skip-when-never-initialised guards, and recovery announcement wiring.</done>
</task>

</tasks>

<verification>
1. `pytest tests/test_speaker_alerts.py -x -q` — all tests pass (existing + new)
2. `ruff check src/shitbox/events/engine.py` — no lint errors
3. `pytest tests/test_i2c_recovery.py tests/test_speaker_alerts.py -x -q` — full phase test suite passes
</verification>

<success_criteria>
- Dead speaker worker thread detected within 30 seconds (health check interval)
- Speaker reinitialised via cleanup() then init() when worker dies
- No reinit attempted when speaker was never initialised (_voice is None)
- All subsystem recoveries announced via TTS and buzzer
- All unit tests pass including 8 new health-check tests
</success_criteria>

<output>
After completion, create `.planning/phases/07-self-healing-and-crash-loop-prevention/07-02-SUMMARY.md`
</output>
