---
phase: 07-self-healing-and-crash-loop-prevention
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/shitbox/events/sampler.py
  - tests/test_i2c_recovery.py
autonomous: true
requirements:
  - HEAL-02
  - HEAL-03

must_haves:
  truths:
    - "When I2C bus locks up, the sampler attempts recovery up to 3 times with backoff before rebooting"
    - "When setup() fails at startup due to I2C lockup, the sampler attempts escalating recovery instead of crashing"
    - "After a successful I2C recovery, the reset counter resets to 0 so future lockups get full attempts"
    - "I2C recovery logs structured events and announces via buzzer and TTS at each stage"
  artifacts:
    - path: "src/shitbox/events/sampler.py"
      provides: "Escalating I2C recovery with counter and backoff"
      contains: "I2C_MAX_RESETS"
    - path: "tests/test_i2c_recovery.py"
      provides: "Unit tests for escalation, backoff, startup recovery, counter reset"
      min_lines: 100
  key_links:
    - from: "src/shitbox/events/sampler.py"
      to: "_i2c_bus_reset"
      via: "escalation counter gating _force_reboot"
      pattern: "_reset_count >= I2C_MAX_RESETS"
    - from: "src/shitbox/events/sampler.py"
      to: "start()"
      via: "setup() wrapped in escalation loop"
      pattern: "for attempt in range"
---

<objective>
Implement escalating I2C bus recovery in HighRateSampler so the system attempts multiple
bit-bang resets with backoff before falling back to reboot, eliminating the crash-loop that
caused ~7 PIDs in 3 minutes during field testing.

Purpose: The root cause of most v1.0 field failures was a tight crash-loop from I2C lockups.
The single-attempt recovery followed by immediate reboot meant every restart hit the same
locked bus, killing in-progress video saves, timelapse state, and sync progress each time.

Output: Modified sampler.py with escalating recovery in both `_sample_loop` and `start()`,
plus comprehensive unit tests covering all escalation paths.
</objective>

<execution_context>
@/Users/tgreen/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tgreen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-self-healing-and-crash-loop-prevention/07-RESEARCH.md
@src/shitbox/events/sampler.py
@tests/test_i2c_recovery.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add escalating I2C recovery to HighRateSampler</name>
  <files>src/shitbox/events/sampler.py</files>
  <action>
Add escalation constants at module level after the existing I2C constants:

```python
I2C_MAX_RESETS = 3
I2C_RESET_BACKOFF_SECONDS = [0, 2, 5]
```

Add `_reset_count: int = 0` instance attribute in `__init__()` alongside `_consecutive_failures`.

Modify `_sample_loop()` exception handler (the `if self._consecutive_failures >= I2C_CONSECUTIVE_FAILURE_THRESHOLD:` block):
- Before calling `_i2c_bus_reset()`, log `reset_attempt` and `max_resets` in the existing `i2c_bus_lockup_detected` warning.
- Apply backoff: `backoff = I2C_RESET_BACKOFF_SECONDS[min(self._reset_count, len(I2C_RESET_BACKOFF_SECONDS) - 1)]` then `time.sleep(backoff)` if > 0.
- Increment `self._reset_count` before calling `_i2c_bus_reset()`.
- On successful recovery: log `i2c_bus_recovery_successful` with `attempt=self._reset_count`, reset both `_consecutive_failures = 0` and `_reset_count = 0`.
- On failed recovery: only call `_force_reboot()` if `self._reset_count >= I2C_MAX_RESETS`. Otherwise let the loop continue (next lockup detection triggers the next attempt).

Modify `start()` to wrap the `setup()` call in an escalation loop:
- Replace the bare `self.setup()` call with a `for attempt in range(I2C_MAX_RESETS + 1):` loop.
- On `setup()` success: break out of the loop.
- On exception: log `sampler_setup_failed` with `error` and `attempt` number.
- If `attempt < I2C_MAX_RESETS`: call `buzzer.beep_i2c_lockup()`, `speaker.speak_i2c_lockup()`, then `self._i2c_bus_reset()` (which includes `setup()` internally — do NOT call `setup()` again after it).
- Apply backoff using `I2C_RESET_BACKOFF_SECONDS[attempt]`.
- If the `_i2c_bus_reset()` succeeds (returns True), break out of the loop.
- If all attempts exhausted: log `sampler_setup_unrecoverable` at critical level, call `_force_reboot()`, and return without starting the thread.

Reset `_reset_count = 0` in `stop()` so a clean restart gets a fresh escalation counter.

IMPORTANT: Do NOT call `setup()` after `_i2c_bus_reset()` — the reset function already calls `setup()` internally. See Pitfall 1 in the research document.
  </action>
  <verify>
    <automated>cd /Users/tgreen/dev/shitbox && python -c "from shitbox.events.sampler import I2C_MAX_RESETS, I2C_RESET_BACKOFF_SECONDS; assert I2C_MAX_RESETS == 3; assert len(I2C_RESET_BACKOFF_SECONDS) == 3; print('OK')"</automated>
  </verify>
  <done>HighRateSampler has escalating I2C recovery with counter, backoff, and startup protection. `_force_reboot()` is only called after `I2C_MAX_RESETS` attempts are exhausted.</done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests for I2C escalation paths</name>
  <files>tests/test_i2c_recovery.py</files>
  <action>
Add new test functions to the existing `tests/test_i2c_recovery.py` file. Follow the existing test patterns in that file (mocked GPIO, mocked smbus2, `sys.modules` injection).

Tests to add:

1. `test_escalation_counter_increments` — Simulate 3 consecutive lockup cycles (5 failures each triggering recovery). After each failed `_i2c_bus_reset()`, verify `_reset_count` increments (1, 2, 3). Mock `_i2c_bus_reset` to return False, mock `_force_reboot` to prevent actual reboot.

2. `test_reboot_only_after_max_resets` — Simulate failures where `_i2c_bus_reset()` returns False. Verify `_force_reboot()` is NOT called until `_reset_count >= I2C_MAX_RESETS` (3). After 3 failed attempts, verify `_force_reboot()` IS called exactly once.

3. `test_backoff_delay_applied` — Mock `time.sleep` and verify the correct backoff delays are applied: 0s for first attempt, 2s for second, 5s for third. Use `I2C_RESET_BACKOFF_SECONDS` values.

4. `test_reset_count_resets_on_success` — Simulate a lockup, failed recovery (count=1), then another lockup, successful recovery. Verify `_reset_count` is reset to 0 after the successful recovery.

5. `test_startup_setup_escalation` — Create a HighRateSampler, mock `setup()` to raise on first call, mock `_i2c_bus_reset()` to return True on first call. Call `start()`. Verify setup was attempted, then `_i2c_bus_reset()` was called, and the sampler thread starts successfully.

6. `test_startup_all_attempts_fail_reboots` — Mock `setup()` to always raise, mock `_i2c_bus_reset()` to always return False. Call `start()`. Verify `_force_reboot()` is called and no thread is started.

7. `test_stop_resets_counter` — Set `_reset_count` to 2, call `stop()`. Verify `_reset_count` is 0.

Use the sentinel exception pattern from Phase 2 tests to break out of `_sample_loop` after the desired number of iterations.
  </action>
  <verify>
    <automated>cd /Users/tgreen/dev/shitbox && pytest tests/test_i2c_recovery.py -x -q</automated>
  </verify>
  <done>All existing I2C recovery tests pass. 7 new tests cover escalation counter, backoff delays, startup protection, counter reset, and reboot gating.</done>
</task>

</tasks>

<verification>
1. `pytest tests/test_i2c_recovery.py -x -q` — all tests pass (existing + new)
2. `ruff check src/shitbox/events/sampler.py` — no lint errors
3. `mypy src/shitbox/events/sampler.py` — no type errors
</verification>

<success_criteria>
- I2C_MAX_RESETS = 3 and I2C_RESET_BACKOFF_SECONDS = [0, 2, 5] are defined
- `_sample_loop` attempts up to 3 resets before calling `_force_reboot()`
- `start()` wraps `setup()` in an escalation loop with the same pattern
- `_reset_count` resets to 0 on successful recovery and on `stop()`
- All unit tests pass including 7 new escalation tests
</success_criteria>

<output>
After completion, create `.planning/phases/07-self-healing-and-crash-loop-prevention/07-01-SUMMARY.md`
</output>
