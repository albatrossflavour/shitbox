---
phase: 02-watchdog-and-self-healing
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - systemd/shitbox-telemetry.service
  - src/shitbox/capture/buzzer.py
  - tests/test_watchdog.py
  - tests/test_buzzer_alerts.py
autonomous: true
requirements:
  - WDOG-01
  - WDOG-02
  - HLTH-02

must_haves:
  truths:
    - "Systemd service unit has WatchdogSec=10 and StartLimitIntervalSec=0"
    - "Service unit has Restart=always and will never permanently stop restarting"
    - "Distinct buzzer patterns exist for service crash, I2C lockup, watchdog miss, ffmpeg stall, and service recovered"
    - "Escalating repeat alerts trigger louder patterns when same failure recurs within 5 minutes"
    - "Buzzer alerts are suppressed during the 30-second boot grace period"
  artifacts:
    - path: "systemd/shitbox-telemetry.service"
      provides: "Hardened systemd unit with WatchdogSec=10 and StartLimitIntervalSec=0"
      contains: "WatchdogSec=10"
    - path: "src/shitbox/capture/buzzer.py"
      provides: "Alert buzzer patterns and BuzzerAlertState escalation tracker"
      contains: "class BuzzerAlertState"
    - path: "tests/test_watchdog.py"
      provides: "Unit tests for systemd unit file parsing"
    - path: "tests/test_buzzer_alerts.py"
      provides: "Unit tests for buzzer alert patterns and escalation"
  key_links:
    - from: "src/shitbox/capture/buzzer.py"
      to: "BuzzerAlertState"
      via: "should_escalate() method"
      pattern: "should_escalate"
    - from: "systemd/shitbox-telemetry.service"
      to: "src/shitbox/events/engine.py"
      via: "WatchdogSec=10 matches existing _notify_systemd WATCHDOG=1 petting"
      pattern: "WatchdogSec=10"
---

<objective>
Harden the systemd service unit for unlimited restarts with a 10-second watchdog timeout,
and add failure-specific buzzer alert patterns with escalation tracking.

Purpose: The service must never permanently stop restarting after rapid crash loops (WDOG-01,
WDOG-02), and the driver must hear distinct buzzer patterns for each failure type so they
can identify problems without looking at a screen (HLTH-02).

Output: Hardened systemd unit file, new buzzer alert functions with escalation state, and
tests for both.
</objective>

<execution_context>
@/Users/tgreen/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tgreen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-watchdog-and-self-healing/02-RESEARCH.md
@.planning/phases/01-boot-recovery/01-02-SUMMARY.md
@systemd/shitbox-telemetry.service
@src/shitbox/capture/buzzer.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Harden systemd unit and add buzzer alert patterns with escalation</name>
  <files>
    systemd/shitbox-telemetry.service
    src/shitbox/capture/buzzer.py
  </files>
  <action>
**systemd/shitbox-telemetry.service:**

1. Change `WatchdogSec=30` to `WatchdogSec=10` (matches RuntimeWatchdogSec=10 that will be
   deployed to the Pi separately via `/etc/systemd/system.conf.d/watchdog.conf`)
2. Add `StartLimitIntervalSec=0` under the `[Service]` section to prevent systemd from
   permanently stopping restarts after rapid crash loops
3. Keep existing `Restart=always` and `RestartSec=5` unchanged
4. Update the comment above WatchdogSec to reflect the new 10s timeout

**src/shitbox/capture/buzzer.py:**

1. Add `BuzzerAlertState` class at module level (after the existing helper functions):
   - `ESCALATION_WINDOW_SECONDS = 300` (5 minutes)
   - `__init__`: `self._last_alerts: dict[str, float] = {}`
   - `should_escalate(alert_type: str) -> bool`: returns True if same alert_type fired
     within the escalation window, updates `_last_alerts[alert_type]` to current time
   - `reset(alert_type: str) -> None`: removes entry from `_last_alerts` (for recovery chirp)

2. Add module-level `_alert_state = BuzzerAlertState()` instance

3. Add `_boot_start_time: float = 0.0` module-level variable and `set_boot_start_time(t: float)`
   function. The engine calls this at startup so alert functions can suppress during the
   30-second grace period.

4. Add `BOOT_GRACE_PERIOD_SECONDS = 30.0` constant

5. Add internal `_should_alert() -> bool` helper that returns False if
   `time.time() - _boot_start_time < BOOT_GRACE_PERIOD_SECONDS`

6. Add new alert functions using 330 Hz (low warning tone), distinct from existing 440/660/880 Hz
   boot and capture tones. Each checks `_should_alert()` before playing. Each checks
   `_alert_state.should_escalate(name)` and if True, plays the pattern twice:

   - `beep_service_crash()`: 1 long low `[(330, 800)]`, name="buzzer-service-crash"
   - `beep_i2c_lockup()`: 3 short low `[(330, 200), (330, 200), (330, 200)]`, name="buzzer-i2c-lockup"
   - `beep_watchdog_miss()`: 2 long low `[(330, 600), (330, 600)]`, name="buzzer-watchdog-miss"
   - `beep_ffmpeg_stall()`: 2 short + 1 long `[(330, 200), (330, 200), (330, 600)]`, name="buzzer-ffmpeg-stall"
   - `beep_service_recovered()`: 1 short high chirp `[(880, 150)]`, name="buzzer-service-recovered"
     Also calls `_alert_state.reset(recovered_service)` where `recovered_service` is an optional
     parameter (defaults to "unknown")

7. For escalation: when `should_escalate()` returns True, concatenate the tones list with itself
   (play pattern twice). Do NOT use volume control (PiicoDev_Buzzer `.volume()` may not be
   available on all firmware versions).

All new functions must have full type annotations and structlog-compatible docstrings.
  </action>
  <verify>
    <automated>ruff check src/shitbox/capture/buzzer.py &amp;&amp; python -c "from shitbox.capture.buzzer import BuzzerAlertState, beep_service_crash, beep_i2c_lockup, beep_watchdog_miss, beep_ffmpeg_stall, beep_service_recovered, set_boot_start_time"</automated>
  </verify>
  <done>
    systemd unit has WatchdogSec=10 and StartLimitIntervalSec=0; buzzer.py exports
    BuzzerAlertState, five new beep_* alert functions, and set_boot_start_time
  </done>
</task>

<task type="auto">
  <name>Task 2: Tests for systemd unit file and buzzer alert patterns</name>
  <files>
    tests/test_watchdog.py
    tests/test_buzzer_alerts.py
  </files>
  <action>
**tests/test_watchdog.py:**

Create unit tests that parse the systemd unit file from the repo:

1. `test_watchdog_unit_file_has_10s`: Read `systemd/shitbox-telemetry.service`, assert
   `WatchdogSec=10` is present in the `[Service]` section
2. `test_service_unit_restart_policy`: Assert `Restart=always` and `StartLimitIntervalSec=0`
   are present in the `[Service]` section
3. `test_service_unit_type_notify`: Assert `Type=notify` is present (required for sd_notify
   watchdog petting)

Use `configparser` with `allow_no_value=True` to parse the INI-style unit file, or simple
string matching on file contents. configparser approach is preferred for robustness.

**tests/test_buzzer_alerts.py:**

1. `test_beep_service_crash_pattern`: Mock `_play_async`, call `beep_service_crash()`,
   assert called with `[(330, 800)]` tones
2. `test_beep_i2c_lockup_pattern`: Mock `_play_async`, call `beep_i2c_lockup()`,
   assert called with 3-short pattern
3. `test_beep_ffmpeg_stall_pattern`: Mock `_play_async`, call `beep_ffmpeg_stall()`,
   assert called with 2-short-1-long pattern
4. `test_beep_service_recovered`: Mock `_play_async`, call `beep_service_recovered()`,
   assert called with `[(880, 150)]`
5. `test_escalation_within_window`: Create `BuzzerAlertState`, call `should_escalate("test")`
   twice in quick succession, assert first returns False and second returns True
6. `test_no_escalation_after_window`: Create `BuzzerAlertState`, call `should_escalate("test")`,
   then monkeypatch `time.time` to return current + 301, call again, assert returns False
7. `test_alerts_suppressed_during_grace`: Set `_boot_start_time` to `time.time()`, mock
   `_play_async`, call `beep_service_crash()`, assert `_play_async` NOT called
8. `test_alerts_active_after_grace`: Set `_boot_start_time` to `time.time() - 31`, mock
   `_play_async`, call `beep_service_crash()`, assert `_play_async` IS called

For tests that check grace period suppression, use `set_boot_start_time()` to control timing.
For all buzzer tests, ensure `_buzzer` module variable is set to a mock (not None) so
`_play_async` proceeds past the None guard.
  </action>
  <verify>
    <automated>pytest tests/test_watchdog.py tests/test_buzzer_alerts.py -x -q</automated>
  </verify>
  <done>
    All systemd unit file assertions pass; all buzzer pattern, escalation, and grace period
    tests pass
  </done>
</task>

</tasks>

<verification>
- `ruff check src/shitbox/capture/buzzer.py` passes with no errors
- `pytest tests/test_watchdog.py tests/test_buzzer_alerts.py -x -q` all pass
- `grep -c "WatchdogSec=10" systemd/shitbox-telemetry.service` returns 1
- `grep -c "StartLimitIntervalSec=0" systemd/shitbox-telemetry.service` returns 1
- `python -c "from shitbox.capture.buzzer import BuzzerAlertState"` succeeds
</verification>

<success_criteria>
- Systemd unit file hardened with WatchdogSec=10 and StartLimitIntervalSec=0
- Five new buzzer alert functions with distinct tone patterns at 330 Hz
- BuzzerAlertState escalation tracker with 5-minute window
- Boot grace period suppression (30 seconds)
- All tests green
</success_criteria>

<output>
After completion, create `.planning/phases/02-watchdog-and-self-healing/02-01-SUMMARY.md`
</output>
