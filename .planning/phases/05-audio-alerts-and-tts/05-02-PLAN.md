---
phase: 05-audio-alerts-and-tts
plan: 02
type: execute
wave: 2
depends_on:
  - 05-01
files_modified:
  - src/shitbox/events/engine.py
  - src/shitbox/health/thermal_monitor.py
  - tests/test_speaker_alerts.py
autonomous: true
requirements:
  - AUDIO-03

must_haves:
  truths:
    - "Boot sequence announces 'System ready' or crash recovery via speaker after buzzer tones"
    - "Thermal warning and critical thresholds trigger spoken announcements alongside buzzer tones"
    - "Waypoint reached triggers spoken announcement with waypoint name and day label"
    - "Distance update announces at configurable interval (default 50 km)"
    - "Speaker initialises in engine.start() after buzzer, controlled by speaker_enabled config"
    - "Speaker cleanup runs in engine.stop() alongside buzzer cleanup"
    - "Audio playback never blocks the engine thread or 100 Hz IMU sampling"
  artifacts:
    - path: "src/shitbox/events/engine.py"
      provides: "Speaker wiring in start(), stop(), boot sequence, waypoints, distance"
      contains: "speaker.init"
    - path: "src/shitbox/health/thermal_monitor.py"
      provides: "Speaker calls alongside buzzer calls for thermal events"
      contains: "speak_thermal"
  key_links:
    - from: "src/shitbox/events/engine.py"
      to: "src/shitbox/capture/speaker.py"
      via: "import and init/speak_*/cleanup calls"
      pattern: "speaker\\.init|speaker\\.speak_"
    - from: "src/shitbox/health/thermal_monitor.py"
      to: "src/shitbox/capture/speaker.py"
      via: "module-level import and speak_thermal_* calls"
      pattern: "speak_thermal_warning|speak_thermal_critical"
    - from: "src/shitbox/events/engine.py"
      to: "src/shitbox/capture/speaker.py"
      via: "_check_waypoints calls speak_waypoint_reached"
      pattern: "speak_waypoint_reached"
---

<objective>
Wire the speaker module into engine.py and thermal_monitor.py so that all existing alert
conditions and system events produce spoken announcements alongside buzzer tones. Add distance
announcement logic and waypoint announcement calls.

Purpose: Connects the speaker module (from Plan 01) to all the hook points identified in
research, completing the AUDIO-03 requirement for contextual announcements.

Output: Engine and thermal monitor wired with speaker calls, integration tests for wiring.
</objective>

<execution_context>
@/Users/tgreen/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tgreen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-audio-alerts-and-tts/05-CONTEXT.md
@.planning/phases/05-audio-alerts-and-tts/05-RESEARCH.md
@.planning/phases/05-audio-alerts-and-tts/05-01-SUMMARY.md
@src/shitbox/capture/buzzer.py
@src/shitbox/events/engine.py
@src/shitbox/health/thermal_monitor.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire speaker into engine.py and thermal_monitor.py</name>
  <files>
    src/shitbox/events/engine.py
    src/shitbox/health/thermal_monitor.py
  </files>
  <action>
**EngineConfig additions** (flat fields, per project pattern):
```python
speaker_enabled: bool = False
speaker_model_path: str = "/var/lib/shitbox/tts/en_US-lessac-medium.onnx"
speaker_distance_announce_interval_km: float = 50.0
```

Wire these from YAML config in `from_yaml_config()`:
```python
speaker_enabled=capture_cfg.get("speaker", {}).get("enabled", False),
speaker_model_path=capture_cfg.get("speaker", {}).get("model_path", "/var/lib/shitbox/tts/en_US-lessac-medium.onnx"),
speaker_distance_announce_interval_km=capture_cfg.get("speaker", {}).get("distance_announce_interval_km", 50.0),
```

**Engine imports** — add at the top alongside buzzer:
```python
from shitbox.capture import buzzer, overlay, speaker
```

**engine.start()** — after the buzzer init block, add speaker init:
```python
if self.config.speaker_enabled:
    speaker.init(self.config.speaker_model_path)
    speaker.set_boot_start_time(time.time())
    was_crash = self.boot_recovery.was_crash if self.boot_recovery else False
    speaker.speak_boot(was_crash=was_crash)
```

**engine.stop()** — add `speaker.cleanup()` alongside buzzer cleanup.

**_check_waypoints()** — after `self._reached_waypoints.add(i)` and the log.info line, add:
```python
speaker.speak_waypoint_reached(waypoint.name, waypoint.day)
```

**Distance announcements** — add `_last_announced_km: float = 0.0` to `__init__()`. In the
telemetry loop where `_daily_km` is updated (after the `self._daily_km += delta_km` line),
add the distance announcement check:
```python
announce_interval = self.config.speaker_distance_announce_interval_km
if announce_interval > 0 and (
    self._daily_km // announce_interval
    > self._last_announced_km // announce_interval
):
    speaker.speak_distance_update(int(self._daily_km))
    self._last_announced_km = self._daily_km
```

Also reset `_last_announced_km = 0.0` where `_daily_km` is reset (AEST day boundary).

Load `_last_announced_km` in `_restore_trip_state()` similarly to `_daily_km` — but it does
not need database persistence (reset on reboot is acceptable for announcement tracking).

**thermal_monitor.py** — import speaker functions at module level (per [03-02] decision:
module-level imports required for patch() in tests):
```python
from shitbox.capture.speaker import (
    speak_thermal_critical,
    speak_thermal_recovered,
    speak_thermal_warning,
    speak_under_voltage,
)
```

Wrap in try/except ImportError with fallback no-op functions (same graceful degradation
pattern as buzzer). Add speaker calls immediately after each corresponding buzzer call:

- After `beep_thermal_warning()` on line ~219: add `speak_thermal_warning()`
- After `beep_thermal_recovered()` on line ~225: add `speak_thermal_recovered()`
- After `beep_thermal_critical()` on line ~235: add `speak_thermal_critical()`
- After `beep_under_voltage()` on line ~263: add `speak_under_voltage()`

Use UK spelling in all new docstrings and comments.
  </action>
  <verify>
    <automated>ruff check src/shitbox/events/engine.py src/shitbox/health/thermal_monitor.py && mypy src/shitbox/events/engine.py src/shitbox/health/thermal_monitor.py --ignore-missing-imports</automated>
    <manual>Verify speaker.init() called in start(), speaker.cleanup() in stop(), speak_waypoint_reached in _check_waypoints, distance announcement logic in telemetry loop, speak_thermal_* calls in thermal_monitor.py</manual>
  </verify>
  <done>Engine imports and initialises speaker alongside buzzer. Boot, waypoint, distance, and thermal announcements all wired. Speaker cleanup runs on shutdown.</done>
</task>

<task type="auto">
  <name>Task 2: Add integration tests for speaker wiring</name>
  <files>
    tests/test_speaker_alerts.py
  </files>
  <action>
Add integration tests to the existing `tests/test_speaker_alerts.py` file (created in Plan 01).
These tests verify the wiring — that engine and thermal_monitor call the correct speaker
functions at the right times.

**AUDIO-03 wiring tests:**

1. `test_engine_boot_calls_speaker` — Patch `speaker.init` and `speaker.speak_boot`. Create a
   minimal `UnifiedEngine` with `speaker_enabled=True`. Call the boot sequence logic. Assert
   `speaker.init()` was called with the model path and `speaker.speak_boot()` was called.

2. `test_engine_waypoint_calls_speaker` — Set up engine with a reached-waypoint scenario.
   Patch `speaker.speak_waypoint_reached`. Trigger `_check_waypoints()` with coordinates
   matching a waypoint. Assert `speak_waypoint_reached` called with waypoint name and day.

3. `test_engine_distance_calls_speaker` — Set engine `_daily_km = 49.0` and
   `_last_announced_km = 0.0` with `speaker_distance_announce_interval_km = 50.0`. Simulate
   a GPS update that pushes `_daily_km` past 50. Patch `speaker.speak_distance_update`.
   Assert called with the km value.

4. `test_thermal_monitor_calls_speaker_on_warning` — Patch both `beep_thermal_warning` and
   `speak_thermal_warning` at module level in thermal_monitor. Create ThermalMonitorService,
   mock `_read_sysfs_temp` to return 70000 (70C). Run one check cycle. Assert both buzzer
   and speaker functions called.

5. `test_engine_stop_calls_speaker_cleanup` — Patch `speaker.cleanup`. Start and stop engine.
   Assert `speaker.cleanup()` was called.

All tests use `unittest.mock.patch` to avoid real hardware. Engine tests should use the
same patterns established in existing engine tests (see `tests/test_*` for patterns).
  </action>
  <verify>
    <automated>pytest tests/test_speaker_alerts.py -x -q</automated>
  </verify>
  <done>5 integration tests pass verifying: engine boot calls speaker, waypoint triggers announcement, distance threshold fires announcement, thermal monitor calls speaker alongside buzzer, engine stop cleans up speaker.</done>
</task>

</tasks>

<verification>
- `ruff check src/shitbox/events/engine.py src/shitbox/health/thermal_monitor.py` — no lint errors
- `mypy src/shitbox/events/engine.py src/shitbox/health/thermal_monitor.py --ignore-missing-imports` — no type errors
- `pytest tests/test_speaker_alerts.py -x -q` — all tests pass (14 from Plan 01 + 5 new = 19 total)
- `pytest tests/ -q` — full suite still green
</verification>

<success_criteria>
- Engine initialises speaker in start(), cleans up in stop()
- Boot sequence announces via speaker after buzzer tones
- Waypoint reached triggers spoken announcement
- Distance announcement fires at configurable interval
- Thermal monitor calls speaker alongside buzzer for all thermal events
- 19 total tests pass (14 unit + 5 integration)
- Full test suite passes without regressions
</success_criteria>

<output>
After completion, create `.planning/phases/05-audio-alerts-and-tts/05-02-SUMMARY.md`
</output>
