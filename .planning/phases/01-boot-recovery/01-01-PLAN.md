---
phase: 01-boot-recovery
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/shitbox/storage/database.py
  - src/shitbox/events/storage.py
  - src/shitbox/sync/boot_recovery.py
  - tests/test_database.py
  - tests/test_boot_recovery.py
  - tests/conftest.py
autonomous: true
requirements:
  - BOOT-01
  - BOOT-02
  - BOOT-03

must_haves:
  truths:
    - "SQLite connections use synchronous=FULL instead of synchronous=NORMAL"
    - "WAL file presence before database.connect() is detected as an unclean shutdown"
    - "Orphaned event JSON files (missing end_time or with status=open) are closed and marked interrupted"
    - "Corrupt/partial JSON files are handled without crashing"
    - "PRAGMA quick_check runs after crash detection, not on clean boots"
    - "Recovery completes in a background thread without blocking callers"
  artifacts:
    - path: "src/shitbox/storage/database.py"
      provides: "synchronous=FULL PRAGMA on every connection"
      contains: "synchronous=FULL"
    - path: "src/shitbox/sync/boot_recovery.py"
      provides: "BootRecoveryService with crash detection, integrity check, orphan closure"
      exports: ["BootRecoveryService"]
    - path: "src/shitbox/events/storage.py"
      provides: "close_orphaned_events() method on EventStorage"
      contains: "close_orphaned_events"
    - path: "tests/test_database.py"
      provides: "BOOT-03 PRAGMA verification test"
    - path: "tests/test_boot_recovery.py"
      provides: "BOOT-01 and BOOT-02 tests"
  key_links:
    - from: "src/shitbox/sync/boot_recovery.py"
      to: "src/shitbox/storage/database.py"
      via: "Database._get_connection() for PRAGMA quick_check"
      pattern: "PRAGMA quick_check"
    - from: "src/shitbox/sync/boot_recovery.py"
      to: "src/shitbox/events/storage.py"
      via: "EventStorage.close_orphaned_events()"
      pattern: "close_orphaned_events"
---

<objective>
Create the BootRecoveryService, add orphan event closure to EventStorage, and change SQLite
synchronous mode to FULL. This plan builds and tests all recovery building blocks before they
are wired into the engine.

Purpose: These are the core mechanisms that make the system survive hard power cuts. Without
synchronous=FULL, committed WAL transactions can be lost. Without orphan closure, events from
a prior crash remain in an undefined state forever.

Output: Three production files (database.py patch, boot_recovery.py new, storage.py patch)
and their tests.
</objective>

<execution_context>
@/Users/tgreen/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tgreen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-boot-recovery/01-CONTEXT.md
@.planning/phases/01-boot-recovery/01-RESEARCH.md
@src/shitbox/storage/database.py
@src/shitbox/events/storage.py
@src/shitbox/sync/batch_sync.py
@src/shitbox/events/detector.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create test scaffolding and BOOT-03 synchronous=FULL</name>
  <files>
    tests/conftest.py
    tests/test_database.py
    tests/test_boot_recovery.py
    src/shitbox/storage/database.py
  </files>
  <action>
  1. Create `tests/conftest.py` with shared fixtures:
     - `tmp_db_path` fixture using `tmp_path` that returns a Path to a temporary SQLite file
     - `db` fixture that creates a `Database(tmp_db_path)`, calls `connect()`, yields it, then
       calls `close()`
     - `event_storage_dir` fixture using `tmp_path` that returns a Path for event JSON files
     - `event_storage` fixture that creates an `EventStorage(base_dir=event_storage_dir)`

  2. Create `tests/test_database.py` with test for BOOT-03:
     - `test_synchronous_full`: Create a Database with tmp_path, connect, then execute
       `PRAGMA synchronous` and assert the result is `2` (FULL). This verifies the PRAGMA
       is set on every new connection.

  3. Create `tests/test_boot_recovery.py` with test stubs (initially failing — will be filled
     in Task 2):
     - `test_wal_crash_detection`: Assert `detect_unclean_shutdown(db_path)` returns True when
       a WAL file exists, False when it does not.
     - `test_integrity_check_on_crash`: Assert BootRecoveryService runs quick_check when
       was_crash is True, and logs the result.
     - `test_no_integrity_check_clean_boot`: Assert quick_check is NOT run on clean boot.
     - `test_orphan_events_closed`: Create event JSON files with missing end_time, run
       close_orphaned_events(), verify they are updated with status=interrupted and an end_time.
     - `test_corrupt_json_handled`: Create a file with invalid JSON, run close_orphaned_events(),
       verify it does not crash and the file is skipped.
     - `test_recovery_complete_event_set`: Assert recovery_complete threading.Event is set after
       _run() completes, even on clean boot.

  4. In `src/shitbox/storage/database.py` line 116, change:
     ```python
     self._local.conn.execute("PRAGMA synchronous=NORMAL")
     ```
     to:
     ```python
     self._local.conn.execute("PRAGMA synchronous=FULL")
     ```
     This is the single most critical change — it makes every committed WAL write durable
     across hard power cuts. One-line change, no other modifications to database.py.

  5. Run `pytest tests/test_database.py -x -q` to confirm the synchronous=FULL test passes.
  </action>
  <verify>
    <automated>cd /Users/tgreen/dev/shitbox && pytest tests/test_database.py::test_synchronous_full -x -q</automated>
    <manual>Confirm database.py line 116 reads synchronous=FULL</manual>
  </verify>
  <done>
  synchronous=FULL PRAGMA is set on every new Database connection. Test proves it returns
  value 2 (FULL). Test scaffolding exists for all BOOT-01 and BOOT-02 tests (some will fail
  until Task 2 creates the implementation).
  </done>
</task>

<task type="auto">
  <name>Task 2: Create BootRecoveryService and EventStorage.close_orphaned_events()</name>
  <files>
    src/shitbox/sync/boot_recovery.py
    src/shitbox/events/storage.py
    tests/test_boot_recovery.py
  </files>
  <action>
  1. Create `src/shitbox/sync/boot_recovery.py` following the BatchSyncService daemon-thread
     pattern. The class has:

     **`detect_unclean_shutdown(db_path: Path) -> bool`** (module-level function):
     - Check if `Path(str(db_path) + "-wal")` exists.
     - IMPORTANT: This must be called BEFORE `database.connect()` which creates the WAL file.
     - Return True if WAL file exists (unclean shutdown), False otherwise.

     **`BootRecoveryService.__init__(self, db: Database, event_storage: EventStorage)`**:
     - Store db, event_storage references.
     - Initialise `was_crash: bool = False`, `orphans_closed: int = 0`,
       `integrity_ok: bool = True`, `recovery_complete: threading.Event()`.

     **`start(self) -> None`**:
     - Create and start a daemon thread named "boot-recovery" targeting `_run`.

     **`_run(self) -> None`**:
     - Wrap `_detect_and_recover()` in try/except that logs any exception.
     - In the finally block, always call `self.recovery_complete.set()`.

     **`_detect_and_recover(self) -> None`**:
     - If `self.was_crash` is True (set by engine before start()):
       - Call `_run_integrity_check()`.
       - Call `self.event_storage.close_orphaned_events()` and store result in
         `self.orphans_closed`.
       - Log `crash_recovery_complete` with integrity_ok and orphans_closed.
     - If `self.was_crash` is False:
       - Log `clean_boot_detected`.

     **`_run_integrity_check(self) -> bool`**:
     - Get a connection from `self.db._get_connection()`.
     - Execute `PRAGMA quick_check`.
     - Fetch all rows, check if result is `["ok"]`.
     - If not ok, log `integrity_check_failed` with the error rows. Set `self.integrity_ok = False`.
     - If ok, log `integrity_check_passed`.
     - Return the boolean result.

     Use `from shitbox.utils.logging import get_logger` for structured logging.
     Use full type annotations. Target Python 3.9 (use `from __future__ import annotations`
     if needed for `X | Y` syntax, or use `Optional[X]` and `Union` instead).

  2. Add `close_orphaned_events(self) -> int` method to `EventStorage` in
     `src/shitbox/events/storage.py`:
     - Iterate over all `.json` files in `self.base_dir` using `rglob("*.json")`.
     - For each file, try to load it with `json.load()`.
     - Catch `json.JSONDecodeError` and `IOError` — log a warning with the filename and continue.
     - If the loaded dict is missing `end_time` OR has `"status": "open"`, then:
       - Set `meta["end_time"]` to the file's `st_mtime` (float timestamp).
       - Set `meta["status"]` to `"interrupted"`.
       - Write the updated dict back to the same file with `json.dump(meta, f, indent=2)`.
       - Log `orphaned_event_closed` with file path and event type.
       - Increment closed counter.
     - Skip the consolidated `events.json` file if it exists in the search path (check filename).
     - Return the total count of closed events.

  3. Update `tests/test_boot_recovery.py` to flesh out all test bodies:
     - `test_wal_crash_detection`: Create a fake WAL file at `{tmp_db}.db-wal`, call
       `detect_unclean_shutdown()`, assert True. Delete it, assert False.
     - `test_integrity_check_on_crash`: Create a BootRecoveryService with a real tmp_path DB.
       Set `was_crash=True`, call `_detect_and_recover()`, assert `integrity_ok` is True.
     - `test_no_integrity_check_clean_boot`: Set `was_crash=False`, call `_detect_and_recover()`.
       Patch `_run_integrity_check` to track if it was called — assert it was NOT called.
     - `test_orphan_events_closed`: Write 2 JSON files to event_storage_dir:
       one with `end_time` present (should be left alone), one without `end_time` (should be
       closed). Run `close_orphaned_events()`, assert return value is 1. Re-read the modified
       file, assert `status == "interrupted"` and `end_time` is set.
     - `test_corrupt_json_handled`: Write a file with `"{ invalid json"` content. Run
       `close_orphaned_events()`, assert it returns 0 and does not raise.
     - `test_recovery_complete_event_set`: Create service, set `was_crash=False`, call `start()`,
       wait on `recovery_complete` with timeout=5s, assert it is set.

  4. Run the full test suite: `pytest tests/ -x -q`.
  </action>
  <verify>
    <automated>cd /Users/tgreen/dev/shitbox && pytest tests/test_boot_recovery.py tests/test_database.py -x -v</automated>
  </verify>
  <done>
  BootRecoveryService exists at src/shitbox/sync/boot_recovery.py with crash detection,
  integrity check, and orphan closure. EventStorage.close_orphaned_events() marks orphaned
  events as interrupted. All 7+ tests pass. No new dependencies added.
  </done>
</task>

</tasks>

<verification>
- `pytest tests/ -x -q` — all tests pass
- `ruff check src/shitbox/sync/boot_recovery.py src/shitbox/storage/database.py src/shitbox/events/storage.py` — no lint errors
- `grep -n "synchronous=FULL" src/shitbox/storage/database.py` — confirms the PRAGMA change
- `grep -n "close_orphaned_events" src/shitbox/events/storage.py` — confirms method exists
</verification>

<success_criteria>
- synchronous=FULL is set on every new Database connection (verified by test)
- BootRecoveryService detects crash via WAL file, runs quick_check, closes orphans
- EventStorage.close_orphaned_events() handles valid JSON, missing end_time, and corrupt files
- All tests pass with no hardware dependencies (pure unit tests using tmp_path)
- No new pip dependencies required
</success_criteria>

<output>
After completion, create `.planning/phases/01-boot-recovery/01-01-SUMMARY.md`
</output>
