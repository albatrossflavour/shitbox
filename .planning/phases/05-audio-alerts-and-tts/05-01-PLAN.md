---
phase: 05-audio-alerts-and-tts
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/shitbox/capture/speaker.py
  - src/shitbox/utils/config.py
  - config/config.yaml
  - tests/test_speaker_alerts.py
autonomous: true
requirements:
  - AUDIO-01
  - AUDIO-02

must_haves:
  truths:
    - "USB speaker is detected by parsing /proc/asound/cards for 'UACDemo' substring"
    - "init() returns False and logs warning when USB speaker is absent (buzzer-only fallback)"
    - "Piper model loads once during init(), not at import time or per-utterance"
    - "speak_*() functions enqueue text without blocking the caller"
    - "Queue drops messages when full (maxsize=2) instead of blocking"
    - "All speak_*() functions are silent no-ops when speaker is not initialised"
    - "Boot grace period suppresses non-boot alerts for 30 seconds after startup"
    - "piper-tts import failure does not crash the module (graceful degradation)"
  artifacts:
    - path: "src/shitbox/capture/speaker.py"
      provides: "SpeakerService module with speak_*() functions mirroring buzzer.py"
      contains: "_detect_usb_speaker"
    - path: "src/shitbox/utils/config.py"
      provides: "SpeakerConfig dataclass"
      contains: "SpeakerConfig"
    - path: "config/config.yaml"
      provides: "Speaker YAML configuration section"
      contains: "speaker:"
    - path: "tests/test_speaker_alerts.py"
      provides: "Unit tests for speaker detection, TTS enqueue, queue behaviour"
      min_lines: 100
  key_links:
    - from: "src/shitbox/capture/speaker.py"
      to: "piper.voice.PiperVoice"
      via: "try/except ImportError with PIPER_AVAILABLE flag"
      pattern: "PIPER_AVAILABLE"
    - from: "src/shitbox/capture/speaker.py"
      to: "/proc/asound/cards"
      via: "Path.read_text() parsing for UACDemo substring"
      pattern: "_detect_usb_speaker"
---

<objective>
Create the speaker.py module with USB speaker detection, Piper TTS synthesis, non-blocking
queue worker, and all speak_*() functions. Add SpeakerConfig dataclass and YAML config section.
Write comprehensive unit tests covering detection, enqueue behaviour, queue overflow, grace
period, and graceful degradation.

Purpose: Establishes the complete audio output module that Plan 02 wires into the engine and
thermal monitor. All speak_*() functions exist and are independently testable before any
call-site wiring happens.

Output: speaker.py module, SpeakerConfig in config.py, YAML config section, test file with
14+ tests covering AUDIO-01 and AUDIO-02 requirements.
</objective>

<execution_context>
@/Users/tgreen/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tgreen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-audio-alerts-and-tts/05-CONTEXT.md
@.planning/phases/05-audio-alerts-and-tts/05-RESEARCH.md
@src/shitbox/capture/buzzer.py
@src/shitbox/utils/config.py
@config/config.yaml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create speaker.py module and SpeakerConfig</name>
  <files>
    src/shitbox/capture/speaker.py
    src/shitbox/utils/config.py
    config/config.yaml
  </files>
  <action>
Create `src/shitbox/capture/speaker.py` mirroring the `buzzer.py` architecture exactly:

**Module-level state** (same pattern as buzzer.py):
- `try: from piper.voice import PiperVoice` / `except ImportError: PIPER_AVAILABLE = False`
- `_voice: Optional[PiperVoice] = None`
- `_alsa_device: Optional[str] = None`
- `_queue: queue.Queue[Optional[str]] = queue.Queue(maxsize=2)`
- `_worker: Optional[threading.Thread] = None`
- `_running = False`
- `BOOT_GRACE_PERIOD_SECONDS = 30.0` and `_boot_start_time: float = 0.0`

**Detection function** `_detect_usb_speaker() -> Optional[str]`:
- Parse `/proc/asound/cards` via `Path.read_text()`
- Search for line containing `"UACDemo"` substring
- Extract card number from line start, return `f"plughw:{card_num},0"`
- Return None on OSError or if not found

**Lifecycle functions**:
- `init(model_path: str) -> bool`: Check PIPER_AVAILABLE, detect USB speaker, load PiperVoice model, start worker thread. Return False on any failure (graceful degradation).
- `cleanup() -> None`: Set `_running = False`, put None sentinel on queue, wait for worker thread.
- `set_boot_start_time(t: float) -> None`: Same pattern as buzzer.py.
- `_should_alert() -> bool`: Same pattern as buzzer.py.

**Worker thread**:
- `_worker_loop()`: Dequeue with timeout=1.0, call `_synthesise_and_play()`, handle `queue.Empty` by continuing, break on None sentinel.
- `_synthesise_and_play(text: str)`: Import `subprocess` and `wave` inside function. Use `tempfile.NamedTemporaryFile(suffix=".wav", delete=False)` for the WAV path. Call `_voice.synthesize(text, wav_file)` via `wave.open()`. Play via `subprocess.run(["aplay", "-D", _alsa_device, "-q", wav_path], timeout=10, check=False)`. Always clean up temp file in `finally` block with `Path.unlink(missing_ok=True)`.

**Enqueue helper**:
- `_enqueue(text: str) -> None`: `_queue.put_nowait(text)`, catch `queue.Full` and log at debug level. Return immediately if `_voice is None` (no-op when uninitialised).

**speak_*() functions** (all call `_enqueue()` with message text):
- `speak_boot(was_crash: bool = False)` — "System ready" or "System recovered after crash"
- `speak_thermal_warning()` — "Warning. CPU temperature high." (uses `_should_alert()` guard)
- `speak_thermal_critical()` — "Critical. CPU temperature critical." (uses `_should_alert()` guard)
- `speak_thermal_recovered()` — "CPU temperature recovered." (uses `_should_alert()` guard)
- `speak_under_voltage()` — "Warning. Under voltage detected." (uses `_should_alert()` guard)
- `speak_service_crash()` — "Warning. Service failure detected." (uses `_should_alert()` guard)
- `speak_service_recovered()` — "Service recovered." (uses `_should_alert()` guard)
- `speak_i2c_lockup()` — "Warning. Sensor bus lockup." (uses `_should_alert()` guard)
- `speak_ffmpeg_stall()` — "Warning. Video recording stalled." (uses `_should_alert()` guard)
- `speak_waypoint_reached(name: str, day: int)` — f"Waypoint reached. {name}. Day {day}."
- `speak_distance_update(km: int)` — f"{km} kilometres driven today."

**Config additions**:

In `config.py`, add `SpeakerConfig` dataclass:
```python
@dataclass
class SpeakerConfig:
    enabled: bool = False
    model_path: str = "/var/lib/shitbox/tts/en_US-lessac-medium.onnx"
    distance_announce_interval_km: float = 50.0
```

Add `speaker: SpeakerConfig` field to `CaptureConfig` (same pattern as existing nested configs). Wire into `_dict_to_dataclass` / `load_config()`.

In `config/config.yaml`, add under `capture:`:
```yaml
  speaker:
    enabled: true
    model_path: /var/lib/shitbox/tts/en_US-lessac-medium.onnx
    distance_announce_interval_km: 50
```

Use UK spelling in all docstrings ("initialise", "synthesise"). Use structlog keyword arguments for all logging.
  </action>
  <verify>
    <automated>ruff check src/shitbox/capture/speaker.py src/shitbox/utils/config.py && mypy src/shitbox/capture/speaker.py src/shitbox/utils/config.py --ignore-missing-imports</automated>
    <manual>speaker.py exists with all speak_*() functions, SpeakerConfig in config.py, speaker section in config.yaml</manual>
  </verify>
  <done>speaker.py module exists with _detect_usb_speaker(), init(), cleanup(), 11 speak_*() functions, queue worker thread, and graceful degradation. SpeakerConfig dataclass added to config.py. YAML config section added.</done>
</task>

<task type="auto">
  <name>Task 2: Write unit tests for speaker module</name>
  <files>
    tests/test_speaker_alerts.py
  </files>
  <action>
Create `tests/test_speaker_alerts.py` with comprehensive unit tests. All tests mock hardware
dependencies (piper, /proc/asound/cards, aplay subprocess). No real hardware required.

**AUDIO-01 tests** (USB speaker detection):

1. `test_usb_speaker_detection` — Mock `/proc/asound/cards` content with a Jieli card line. Assert `_detect_usb_speaker()` returns correct `plughw:N,0` string.

2. `test_usb_speaker_not_found` — Mock `/proc/asound/cards` with no Jieli card. Assert returns None.

3. `test_usb_speaker_oserror` — Mock `Path.read_text()` raising OSError. Assert returns None (no crash).

4. `test_init_fallback_no_speaker` — Patch `_detect_usb_speaker` to return None. Call `init()`. Assert returns False. Assert speak_*() functions are no-ops.

5. `test_init_piper_not_available` — Set `speaker.PIPER_AVAILABLE = False`. Call `init()`. Assert returns False.

**AUDIO-02 tests** (TTS enqueue and queue behaviour):

6. `test_speak_boot_clean` — Patch `_enqueue`. Call `speak_boot(was_crash=False)`. Assert `_enqueue` called with "System ready".

7. `test_speak_boot_crash` — Patch `_enqueue`. Call `speak_boot(was_crash=True)`. Assert `_enqueue` called with crash recovery text.

8. `test_speak_thermal_warning` — Set boot time far in past. Patch `_enqueue`. Call `speak_thermal_warning()`. Assert `_enqueue` called with thermal warning text.

9. `test_speak_thermal_critical` — Same setup. Call `speak_thermal_critical()`. Assert correct text.

10. `test_speaker_noop_when_not_init` — Without calling `init()`, call all speak_*() functions. Assert no exceptions, `_enqueue` not called (because `_voice is None`).

11. `test_queue_drops_when_full` — Set `_voice` to a mock (so _enqueue doesn't short-circuit). Fill the queue to maxsize. Call `_enqueue()` again. Assert no exception raised (message dropped silently).

12. `test_boot_grace_suppresses_alerts` — Set `_boot_start_time` to `time.time()` (just started). Patch `_enqueue`. Call `speak_thermal_warning()`. Assert `_enqueue` NOT called (suppressed by grace period). Verify `speak_boot()` is NOT suppressed (boot messages bypass grace check).

**AUDIO-03 tests** (contextual announcements — message content only, wiring tested in Plan 02):

13. `test_speak_waypoint_reached` — Patch `_enqueue`. Call `speak_waypoint_reached("Broken Hill", 3)`. Assert text contains "Broken Hill" and "Day 3".

14. `test_speak_distance_update` — Patch `_enqueue`. Call `speak_distance_update(150)`. Assert text contains "150" and "kilometres".

Each test must reset module-level state (use a fixture that saves/restores `_voice`, `_running`, `_boot_start_time`, `_queue`). Use `unittest.mock.patch` and `pytest` fixtures. Import the speaker module and patch its internals.
  </action>
  <verify>
    <automated>pytest tests/test_speaker_alerts.py -x -q</automated>
  </verify>
  <done>14 tests pass covering USB detection (3 tests), init fallback (2 tests), TTS enqueue (4 tests), no-op behaviour (1 test), queue overflow (1 test), grace period (1 test), contextual messages (2 tests). Full speaker module coverage for AUDIO-01 and AUDIO-02.</done>
</task>

</tasks>

<verification>
- `ruff check src/shitbox/capture/speaker.py` — no lint errors
- `mypy src/shitbox/capture/speaker.py --ignore-missing-imports` — no type errors
- `pytest tests/test_speaker_alerts.py -x -q` — all 14 tests pass
- `pytest tests/ -q` — full suite still green (no regressions)
</verification>

<success_criteria>
- speaker.py exists with 11 speak_*() functions, queue worker, USB detection, graceful degradation
- SpeakerConfig dataclass in config.py, speaker section in config.yaml
- 14 unit tests pass covering AUDIO-01 and AUDIO-02 requirements
- Full test suite passes without regressions
</success_criteria>

<output>
After completion, create `.planning/phases/05-audio-alerts-and-tts/05-01-SUMMARY.md`
</output>
