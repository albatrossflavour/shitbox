---
phase: 02-watchdog-and-self-healing
plan: "03"
type: execute
wave: 2
depends_on:
  - "02-01"
files_modified:
  - src/shitbox/events/sampler.py
  - src/shitbox/events/engine.py
  - tests/test_i2c_recovery.py
autonomous: true
requirements:
  - WDOG-04

must_haves:
  truths:
    - "After 5 consecutive I2C read failures, a 9-clock bit-bang recovery is attempted"
    - "Consecutive failure counter resets to 0 on any successful read"
    - "After successful bit-bang recovery, MPU6050 is reinitialised before resuming reads"
    - "If bit-bang recovery fails, the system forces a reboot"
    - "I2C recovery triggers the buzzer i2c_lockup alert"
  artifacts:
    - path: "src/shitbox/events/sampler.py"
      provides: "I2C bus lockup detection and 9-clock bit-bang recovery"
      contains: "_i2c_bus_reset"
    - path: "src/shitbox/events/engine.py"
      provides: "Boot start time wired to buzzer for grace period suppression"
      contains: "set_boot_start_time"
    - path: "tests/test_i2c_recovery.py"
      provides: "Unit tests for I2C recovery with mocked GPIO and smbus2"
  key_links:
    - from: "src/shitbox/events/sampler.py"
      to: "src/shitbox/capture/buzzer.py"
      via: "beep_i2c_lockup() called on recovery attempt"
      pattern: "beep_i2c_lockup"
    - from: "src/shitbox/events/sampler.py"
      to: "RPi.GPIO"
      via: "GPIO.output for 9-clock bit-bang on GPIO2/GPIO3"
      pattern: "GPIO.output"
    - from: "src/shitbox/events/engine.py"
      to: "src/shitbox/capture/buzzer.py"
      via: "set_boot_start_time called during engine start"
      pattern: "set_boot_start_time"
---

<objective>
Add I2C bus lockup detection and 9-clock bit-bang recovery to the high-rate IMU sampler,
with buzzer alerting and reboot fallback.

Purpose: The I2C bus can lock up when a sensor holds SDA low mid-transfer (common under
vibration and power glitches). Without recovery, the 100 Hz IMU sampler stops producing
data silently. The 9-clock bit-bang technique pulses SCL to release the stuck slave, then
reinitialises the sensor (WDOG-04).

Output: I2C recovery in sampler.py, engine wiring for buzzer boot grace period, and tests.
</objective>

<execution_context>
@/Users/tgreen/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tgreen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-watchdog-and-self-healing/02-RESEARCH.md
@.planning/phases/02-watchdog-and-self-healing/02-01-SUMMARY.md
@src/shitbox/events/sampler.py
@src/shitbox/events/engine.py
@src/shitbox/capture/buzzer.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add I2C bus lockup recovery to HighRateSampler</name>
  <files>
    src/shitbox/events/sampler.py
    src/shitbox/events/engine.py
  </files>
  <action>
**src/shitbox/events/sampler.py:**

1. Add constants at module level:
   - `I2C_CONSECUTIVE_FAILURE_THRESHOLD = 5` (triggers recovery after 5 failures = ~50ms at 100 Hz)
   - `I2C_RECOVERY_DELAY_SECONDS = 0.1` (100ms delay after GPIO cleanup before smbus2 reopen)
   - `SCL_PIN = 3` (GPIO3 = physical pin 5)
   - `SDA_PIN = 2` (GPIO2 = physical pin 3)

2. Add instance variables in `__init__`:
   - `self._consecutive_failures: int = 0`

3. Add `_i2c_bus_reset(self) -> bool` method:
   - Import `RPi.GPIO as GPIO` inside the method (graceful if not on Pi)
   - Close `self._bus` (catch and ignore exceptions)
   - `GPIO.setwarnings(False)` to avoid conflicts with other GPIO users
   - `GPIO.setmode(GPIO.BCM)`
   - `GPIO.setup(SCL_PIN, GPIO.OUT, initial=GPIO.HIGH)`
   - Pulse SCL 9 times: LOW then HIGH with 5 microsecond half-cycles (`time.sleep(0.000005)`)
   - Generate STOP condition: `GPIO.setup(SDA_PIN, GPIO.OUT, initial=GPIO.LOW)`,
     sleep 5us, `GPIO.output(SDA_PIN, GPIO.HIGH)`
   - `GPIO.cleanup([SCL_PIN, SDA_PIN])` â€” selective cleanup, NOT global
   - Sleep `I2C_RECOVERY_DELAY_SECONDS` (100ms) to let I2C driver reclaim pins
   - Reopen smbus2: `import smbus2; self._bus = smbus2.SMBus(self.i2c_bus)`
   - Call `self.setup()` to reinitialise MPU6050 registers (avoids stale data pitfall)
   - Return True on success
   - If any exception during reopen/setup: log error, return False

4. Add `_force_reboot(self) -> None` method:
   - Log `log.critical("i2c_recovery_failed_forcing_reboot")`
   - `import subprocess; subprocess.run(["sudo", "systemctl", "reboot"], check=False)`

5. Modify `_sample_loop()` exception handler:
   - On successful read: reset `self._consecutive_failures = 0`
   - On exception: increment `self._consecutive_failures`
   - If `self._consecutive_failures >= I2C_CONSECUTIVE_FAILURE_THRESHOLD`:
     - Log warning: `log.warning("i2c_bus_lockup_detected", consecutive_failures=self._consecutive_failures)`
     - Call `buzzer.beep_i2c_lockup()` (import buzzer at top of file)
     - Call `self._i2c_bus_reset()`
     - If returns True: log info `"i2c_bus_recovery_successful"`, call `buzzer.beep_service_recovered("i2c")`, reset `_consecutive_failures = 0`
     - If returns False: call `self._force_reboot()`

**src/shitbox/events/engine.py:**

1. Import `set_boot_start_time` from `shitbox.capture.buzzer`
2. In the `start()` method, after buzzer.init() and before starting services, call
   `buzzer.set_boot_start_time(time.time())` so all buzzer alert functions know when boot
   started and can suppress alerts during the 30-second grace period

Full type annotations required. Use structlog keyword arguments for all log messages.
  </action>
  <verify>
    <automated>ruff check src/shitbox/events/sampler.py src/shitbox/events/engine.py &amp;&amp; python -c "from shitbox.events.sampler import I2C_CONSECUTIVE_FAILURE_THRESHOLD; assert I2C_CONSECUTIVE_FAILURE_THRESHOLD == 5"</automated>
  </verify>
  <done>
    HighRateSampler detects I2C lockup after 5 consecutive failures, attempts 9-clock bit-bang
    recovery with GPIO2/GPIO3, reinitialises MPU6050 after recovery, reboots if recovery fails,
    and alerts via buzzer; engine wires boot start time for grace period
  </done>
</task>

<task type="auto">
  <name>Task 2: Tests for I2C bus lockup recovery</name>
  <files>
    tests/test_i2c_recovery.py
  </files>
  <action>
Create `tests/test_i2c_recovery.py` with unit tests for I2C recovery. All hardware
dependencies (RPi.GPIO, smbus2) must be mocked.

1. **Fixture:** Create a `sampler` fixture that builds a `HighRateSampler` with a mock
   `RingBuffer` and mocked `_bus` (smbus2.SMBus mock). Do NOT call `setup()` or `start()`.
   Set `sampler._bus` to the mock bus directly.

2. `test_failure_counter_resets_on_success`:
   - Set `sampler._consecutive_failures = 3`
   - Mock `sampler._bus.read_i2c_block_data` to return 14 bytes of valid data
   - Call `sampler._read_sample()` (should succeed)
   - Simulate what `_sample_loop` does: reset counter on success
   - Since we test the loop logic, instead: patch `_read_sample` to succeed,
     manually run one iteration of the loop logic, assert `_consecutive_failures == 0`

3. `test_failure_counter_increments_on_error`:
   - Set `_consecutive_failures = 0`
   - Mock `_read_sample` to raise `OSError`
   - Manually execute the exception path, assert `_consecutive_failures == 1`

4. `test_bitbang_triggered_after_5_failures`:
   - Set `_consecutive_failures = 4` (will become 5 on next failure)
   - Mock `_read_sample` to raise `OSError`
   - Mock `_i2c_bus_reset` to return True
   - Mock `buzzer.beep_i2c_lockup` and `buzzer.beep_service_recovered`
   - Execute the exception path
   - Assert `_i2c_bus_reset` called once
   - Assert `beep_i2c_lockup` called once
   - Assert `beep_service_recovered` called once
   - Assert `_consecutive_failures` reset to 0

5. `test_reboot_on_bitbang_failure`:
   - Set `_consecutive_failures = 4`
   - Mock `_read_sample` to raise `OSError`
   - Mock `_i2c_bus_reset` to return False
   - Mock `_force_reboot`
   - Execute the exception path
   - Assert `_force_reboot` called once

6. `test_i2c_bus_reset_gpio_sequence`:
   - Mock `RPi.GPIO` module (use `unittest.mock.MagicMock`)
   - Mock `smbus2.SMBus` constructor
   - Mock `self.setup`
   - Call `_i2c_bus_reset()`
   - Assert GPIO.setmode called with BCM
   - Assert GPIO.setup called for SCL_PIN
   - Assert GPIO.output called at least 18 times (9 LOW + 9 HIGH for clock pulses)
   - Assert GPIO.cleanup called with `[SCL_PIN, SDA_PIN]` (selective, not global)
   - Assert smbus2.SMBus called with correct bus number
   - Assert self.setup called once (reinitialise MPU6050)

7. `test_i2c_bus_reset_returns_false_on_smbus_failure`:
   - Mock GPIO to succeed
   - Mock smbus2.SMBus to raise OSError
   - Call `_i2c_bus_reset()`
   - Assert returns False

Use `unittest.mock.patch` for module-level imports (RPi.GPIO, smbus2, subprocess).
Use `monkeypatch` or `patch.object` for instance method mocking.
  </action>
  <verify>
    <automated>pytest tests/test_i2c_recovery.py -x -q</automated>
  </verify>
  <done>
    All I2C recovery tests pass: failure counter mechanics, bit-bang trigger threshold,
    GPIO sequence verification, reboot fallback, and smbus2 reopen failure handling
  </done>
</task>

</tasks>

<verification>
- `ruff check src/shitbox/events/sampler.py` passes
- `pytest tests/test_i2c_recovery.py -x -q` all pass
- `pytest tests/ -x -q` full suite passes (no regressions)
- `grep -c "_i2c_bus_reset" src/shitbox/events/sampler.py` returns at least 2
- `grep -c "I2C_CONSECUTIVE_FAILURE_THRESHOLD" src/shitbox/events/sampler.py` returns at least 1
</verification>

<success_criteria>
- I2C lockup detected after 5 consecutive failures at 100 Hz
- 9-clock bit-bang recovery pulses SCL on GPIO3 with selective GPIO cleanup
- MPU6050 reinitialised after successful bus recovery
- System reboots if bit-bang recovery fails
- Buzzer alerts on lockup detection and chirps on successful recovery
- Engine passes boot start time to buzzer for grace period
- All tests green including full suite regression check
</success_criteria>

<output>
After completion, create `.planning/phases/02-watchdog-and-self-healing/02-03-SUMMARY.md`
</output>
