---
phase: 01-boot-recovery
plan: 02
type: execute
wave: 2
depends_on:
  - "01-01"
files_modified:
  - src/shitbox/events/engine.py
  - src/shitbox/capture/buzzer.py
  - tests/test_engine_boot.py
autonomous: true
requirements:
  - BOOT-01
  - BOOT-02
  - BOOT-03

must_haves:
  truths:
    - "Engine detects WAL file BEFORE database.connect() and passes crash state to BootRecoveryService"
    - "BootRecoveryService.start() is called in engine startup without blocking data capture"
    - "Buzzer plays single short beep on clean boot, double beep on crash recovery"
    - "get_status() includes recovery_was_crash and recovery_complete fields for OLED"
    - "Prometheus gauge shitbox_boot_was_crash is written after recovery completes"
  artifacts:
    - path: "src/shitbox/events/engine.py"
      provides: "BootRecoveryService wiring in start(), recovery fields in get_status()"
      contains: "BootRecoveryService"
    - path: "src/shitbox/capture/buzzer.py"
      provides: "beep_clean_boot() and beep_crash_recovery() functions"
      contains: "beep_crash_recovery"
    - path: "tests/test_engine_boot.py"
      provides: "Integration tests for boot recovery wiring"
  key_links:
    - from: "src/shitbox/events/engine.py"
      to: "src/shitbox/sync/boot_recovery.py"
      via: "import and instantiate BootRecoveryService in start()"
      pattern: "BootRecoveryService"
    - from: "src/shitbox/events/engine.py"
      to: "src/shitbox/capture/buzzer.py"
      via: "beep_clean_boot or beep_crash_recovery after recovery"
      pattern: "beep_crash_recovery|beep_clean_boot"
    - from: "src/shitbox/events/engine.py"
      to: "get_status() dict"
      via: "recovery_was_crash and recovery_complete keys"
      pattern: "recovery_was_crash"
---

<objective>
Wire BootRecoveryService into UnifiedEngine.start(), add recovery-aware buzzer patterns,
expose recovery state in get_status() for OLED, and send the boot_was_crash Prometheus metric.

Purpose: The building blocks from Plan 01 are useless until wired into the engine startup
sequence. This plan integrates them so recovery actually happens on every boot.

Output: Modified engine.py with recovery wiring, new buzzer functions, integration tests.
</objective>

<execution_context>
@/Users/tgreen/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tgreen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-boot-recovery/01-CONTEXT.md
@.planning/phases/01-boot-recovery/01-RESEARCH.md
@.planning/phases/01-boot-recovery/01-01-SUMMARY.md
@src/shitbox/events/engine.py
@src/shitbox/capture/buzzer.py
@src/shitbox/display/oled.py
@src/shitbox/sync/boot_recovery.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add buzzer patterns and wire BootRecoveryService into engine</name>
  <files>
    src/shitbox/capture/buzzer.py
    src/shitbox/events/engine.py
  </files>
  <action>
  1. Add two new functions to `src/shitbox/capture/buzzer.py`:

     ```python
     def beep_clean_boot() -> None:
         """Single short tone: clean boot confirmed."""
         _play_async([(880, 200)], name="buzzer-clean-boot")

     def beep_crash_recovery() -> None:
         """Double beep: crash was detected, recovery ran."""
         _play_async([(880, 200), (880, 200)], name="buzzer-crash-recovery")
     ```

     These play AFTER the existing `beep_boot()` (three ascending tones). They are the
     recovery-specific signals.

  2. Modify `src/shitbox/events/engine.py` — the `start()` method. The key constraint is that
     WAL detection MUST happen BEFORE `self.database.connect()` (line 1317) because connect()
     creates the WAL file.

     **Add import** at the top of engine.py:
     ```python
     from shitbox.sync.boot_recovery import BootRecoveryService, detect_unclean_shutdown
     ```

     **Add to `__init__`** (after event_storage creation):
     ```python
     self.boot_recovery: Optional[BootRecoveryService] = None
     ```

     **Modify `start()`** — insert WAL check BEFORE `self.database.connect()`:

     ```python
     # --- Boot recovery: detect crash BEFORE database.connect() creates the WAL ---
     was_crash = detect_unclean_shutdown(self.database.db_path)
     if was_crash:
         log.info("unclean_shutdown_detected", db_path=str(self.database.db_path))

     # Initialise database (this creates the WAL file — detection must be above)
     self.database.connect()

     # Start boot recovery in background (does not block data capture)
     self.boot_recovery = BootRecoveryService(self.database, self.event_storage)
     self.boot_recovery.was_crash = was_crash
     self.boot_recovery.start()
     ```

     **Modify buzzer section** (currently at line ~1384-1387). Replace:
     ```python
     if self.config.buzzer_enabled:
         buzzer.init()
         buzzer.beep_boot()
     ```
     With:
     ```python
     if self.config.buzzer_enabled:
         buzzer.init()
         buzzer.beep_boot()
         # Recovery-specific beep after boot tone
         if self.boot_recovery and self.boot_recovery.was_crash:
             buzzer.beep_crash_recovery()
         else:
             buzzer.beep_clean_boot()
     ```

     **Add Prometheus metric send** — after `self.boot_recovery.start()`, spawn a daemon
     thread that waits for recovery_complete, then sends the metric:

     ```python
     def _send_boot_metric() -> None:
         """Send boot_was_crash gauge after recovery completes."""
         if self.boot_recovery is None:
             return
         self.boot_recovery.recovery_complete.wait(timeout=30)
         try:
             import time as _time
             from shitbox.sync.prometheus_write import encode_remote_write
             metric_value = 1.0 if self.boot_recovery.was_crash else 0.0
             timestamp_ms = int(_time.time() * 1000)
             metrics = [
                 (
                     "shitbox_boot_was_crash",
                     {"instance": "shitbox-car", "car": "shitbox"},
                     metric_value,
                     timestamp_ms,
                 )
             ]
             if (
                 self.config.prometheus_enabled
                 and self.config.uplink_enabled
                 and self.config.prometheus_remote_write_url
                 and self.connection.is_connected
             ):
                 import requests
                 data = encode_remote_write(metrics)
                 requests.post(
                     self.config.prometheus_remote_write_url,
                     data=data,
                     headers={
                         "Content-Type": "application/x-protobuf",
                         "Content-Encoding": "snappy",
                         "X-Prometheus-Remote-Write-Version": "0.1.0",
                     },
                     timeout=10,
                 )
                 log.info("boot_metric_sent", was_crash=self.boot_recovery.was_crash)
         except Exception as e:
             log.warning("boot_metric_send_failed", error=str(e))

     threading.Thread(target=_send_boot_metric, daemon=True, name="boot-metric").start()
     ```

     Place this thread spawn right after the `self.boot_recovery.start()` call. It runs in
     the background and is a best-effort metric — failure is logged and ignored.

  3. Modify `get_status()` in engine.py to include recovery state. Add these keys to the
     returned dict:

     ```python
     "recovery_was_crash": (
         self.boot_recovery.was_crash if self.boot_recovery else False
     ),
     "recovery_complete": (
         self.boot_recovery.recovery_complete.is_set() if self.boot_recovery else True
     ),
     "recovery_orphans_closed": (
         self.boot_recovery.orphans_closed if self.boot_recovery else 0
     ),
     ```

     The OLED display reads get_status() and can show recovery state. Per the locked decision,
     OLED shows recovery status until GPS fix is acquired, then switches to normal display.
     The OLED rendering logic changes are outside this phase scope (Phase 2 handles OLED
     improvements) — but the data is now available in the status dict.

  4. In `stop()`, no changes needed for BootRecoveryService — it is a one-shot daemon thread
     that exits after recovery completes. No stop() method required.
  </action>
  <verify>
    <automated>cd /Users/tgreen/dev/shitbox && ruff check src/shitbox/events/engine.py src/shitbox/capture/buzzer.py</automated>
    <manual>Review engine.py start() to confirm WAL check is before database.connect()</manual>
  </verify>
  <done>
  BootRecoveryService is wired into engine startup. WAL detection occurs before
  database.connect(). Recovery runs in background thread. Buzzer plays distinct tones for
  clean/crash boot. get_status() exposes recovery state for OLED. Prometheus metric is sent
  as a best-effort one-shot.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integration tests for engine boot recovery wiring</name>
  <files>tests/test_engine_boot.py</files>
  <action>
  Create `tests/test_engine_boot.py` with integration tests that verify the engine wiring
  without requiring hardware. These tests mock hardware-dependent components.

  1. **`test_engine_detects_wal_before_connect`**: Create a tmp_path DB file and a WAL file
     next to it. Import `detect_unclean_shutdown` and verify it returns True. Remove the WAL
     file, verify it returns False. This confirms the detection function works with real paths.

  2. **`test_buzzer_clean_boot_called`**: Patch `buzzer.beep_clean_boot` and
     `buzzer.beep_crash_recovery`. Create a mock engine scenario where `was_crash=False`.
     Verify `beep_clean_boot` was called and `beep_crash_recovery` was NOT called.
     (Since we cannot easily instantiate UnifiedEngine without hardware, test the buzzer
     functions directly — verify they exist and are callable.)

  3. **`test_buzzer_crash_recovery_called`**: Same as above but verify that
     `buzzer.beep_crash_recovery` is callable and produces the expected tone sequence.
     Patch `_play_async` and verify it receives `[(880, 200), (880, 200)]`.

  4. **`test_get_status_includes_recovery_fields`**: This is harder to test without a full
     engine. Instead, verify the BootRecoveryService exposes the expected attributes:
     `was_crash`, `recovery_complete`, `orphans_closed`, `integrity_ok`. Create an instance
     with mocked db and event_storage, verify all attributes exist with correct defaults.

  5. **`test_full_recovery_flow`**: End-to-end test using tmp_path:
     - Create a Database, connect it, insert a reading, close it WITHOUT calling close()
       (simulate crash by just letting it go — the WAL file will persist).
     - Create event JSON files with no end_time.
     - Now call `detect_unclean_shutdown()` — assert True.
     - Create a new Database instance, connect it.
     - Create BootRecoveryService, set was_crash=True, call `_detect_and_recover()`.
     - Assert `integrity_ok` is True, `orphans_closed` >= 1.
     - Re-read the event JSON — assert `status == "interrupted"`.

  Use `unittest.mock.patch` for buzzer and hardware mocking. Use `tmp_path` for all file
  operations. No hardware dependencies.
  </action>
  <verify>
    <automated>cd /Users/tgreen/dev/shitbox && pytest tests/ -x -v</automated>
  </verify>
  <done>
  All tests pass including integration tests. The full recovery flow is verified end-to-end
  using tmp_path files. Buzzer functions exist and produce correct tone patterns. Recovery
  attributes are accessible for OLED/status reporting.
  </done>
</task>

</tasks>

<verification>
- `pytest tests/ -x -v` — all tests pass (unit + integration)
- `ruff check src/` — no lint errors
- `grep -n "detect_unclean_shutdown\|BootRecoveryService" src/shitbox/events/engine.py` — confirms wiring
- `grep -n "beep_clean_boot\|beep_crash_recovery" src/shitbox/capture/buzzer.py` — confirms new functions
- `grep -n "recovery_was_crash" src/shitbox/events/engine.py` — confirms get_status() integration
</verification>

<success_criteria>
- Engine detects WAL file before database.connect() on every startup
- BootRecoveryService runs in background without blocking IMU/GPS startup
- Buzzer plays distinct patterns: 3 ascending tones (boot) + 1 short (clean) or 2 short (crash)
- get_status() includes recovery_was_crash, recovery_complete, recovery_orphans_closed
- Prometheus shitbox_boot_was_crash gauge sent as best-effort on each boot
- All tests pass with no hardware dependencies
</success_criteria>

<output>
After completion, create `.planning/phases/01-boot-recovery/01-02-SUMMARY.md`
</output>
