---
phase: 04-remote-health-and-stage-tracking
plan: "02"
type: execute
wave: 2
depends_on:
  - "04-01"
files_modified:
  - src/shitbox/utils/config.py
  - config/config.yaml
  - src/shitbox/events/engine.py
  - tests/test_trip_tracking.py
autonomous: true
requirements:
  - STGE-01
  - STGE-02
  - STGE-03

must_haves:
  truths:
    - "Odometer accumulates GPS distance only when speed >= 5 km/h and persists to SQLite every 60 seconds"
    - "Daily distance resets on first boot of a new AEST calendar day and persists across mid-day reboots"
    - "Waypoints within 5 km are marked as reached, persisted in SQLite, and survive reboots"
    - "Route waypoints are defined in YAML config under sensors.gps.route and loaded into WaypointConfig dataclasses"
  artifacts:
    - path: "src/shitbox/utils/config.py"
      provides: "WaypointConfig and RouteConfig dataclasses"
      contains: "class WaypointConfig"
    - path: "config/config.yaml"
      provides: "Route waypoints section"
      contains: "route:"
    - path: "tests/test_trip_tracking.py"
      provides: "Unit tests for STGE-01, STGE-02, STGE-03"
      min_lines: 80
  key_links:
    - from: "src/shitbox/events/engine.py"
      to: "src/shitbox/storage/database.py"
      via: "set_trip_state/get_trip_state for odometer persistence"
      pattern: "set_trip_state|get_trip_state"
    - from: "src/shitbox/events/engine.py"
      to: "src/shitbox/storage/database.py"
      via: "record_waypoint_reached for waypoint persistence"
      pattern: "record_waypoint_reached"
    - from: "src/shitbox/utils/config.py"
      to: "src/shitbox/events/engine.py"
      via: "route_waypoints loaded from config into EngineConfig"
      pattern: "route_waypoints"
---

<objective>
Add GPS-based distance tracking (odometer + daily) and waypoint-based rally stage progress so the
car knows where it is on the route.

Purpose: STGE-01/02/03 require cumulative distance, daily distance with AEST day boundary resets,
and waypoint proximity detection. All state persists in SQLite to survive reboots. Route defined
as ordered waypoints in YAML config.

Output: Config dataclasses for waypoints, engine distance/waypoint logic, config.yaml route section,
passing tests.
</objective>

<execution_context>
@/Users/tgreen/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tgreen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-remote-health-and-stage-tracking/04-RESEARCH.md
@.planning/phases/04-remote-health-and-stage-tracking/04-01-SUMMARY.md
@src/shitbox/utils/config.py
@src/shitbox/events/engine.py
@src/shitbox/storage/database.py
@config/config.yaml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Config dataclasses, engine distance/waypoint logic, and config.yaml route section</name>
  <files>
    src/shitbox/utils/config.py
    config/config.yaml
    src/shitbox/events/engine.py
  </files>
  <action>
**config.py — New dataclasses:**

Add `WaypointConfig` dataclass:
```python
@dataclass
class WaypointConfig:
    name: str = ""
    day: int = 1
    lat: float = 0.0
    lon: float = 0.0
```

Add `RouteConfig` dataclass:
```python
@dataclass
class RouteConfig:
    waypoints: List[WaypointConfig] = field(default_factory=list)
```

Update `GPSConfig` to include `route: RouteConfig = field(default_factory=RouteConfig)`.

In `load_config()`, handle the waypoints list explicitly since `_dict_to_dataclass` does not handle lists of dataclasses. After building GPSConfig, convert raw dict waypoints:
```python
route_data = gps_dict.get("route", {})
waypoints = [WaypointConfig(**w) for w in route_data.get("waypoints", [])]
# Assign to the already-built config object
config.sensors.gps.route = RouteConfig(waypoints=waypoints)
```

**config.yaml — Route section:**

Add under `sensors.gps`:
```yaml
    route:
      waypoints: []
      # Populate before the rally, e.g.:
      # - name: "Port Douglas"
      #   day: 1
      #   lat: -16.4838
      #   lon: 145.4673
      # - name: "Townsville"
      #   day: 1
      #   lat: -19.2590
      #   lon: 146.8169
```

Leave the waypoints list empty in the default config — the user populates it before the rally.

**engine.py — EngineConfig extension:**

Add flat field: `route_waypoints: list = field(default_factory=list)` (contains WaypointConfig objects).

In `from_yaml_config()`, map: `route_waypoints=config.sensors.gps.route.waypoints`.

**engine.py — Distance tracking state:**

Add to `__init__`:
- `self._odometer_km: float = 0.0`
- `self._daily_km: float = 0.0`
- `self._last_known_lat: Optional[float] = None`
- `self._last_known_lon: Optional[float] = None`
- `self._last_trip_persist: float = 0.0`
- `self._reached_waypoints: set = set()`
- `TRIP_PERSIST_INTERVAL_S = 60.0` (as a class constant or module constant)

Add AEST helper (module-level or static method):
```python
AEST_OFFSET = timedelta(hours=10)

def _current_aest_date() -> str:
    return (datetime.now(timezone.utc) + AEST_OFFSET).strftime("%Y-%m-%d")
```

**engine.py — Boot loading in start():**

After database is connected, load trip state:
```python
self._odometer_km = self.database.get_trip_state("odometer_km") or 0.0
self._daily_km = self.database.get_trip_state("daily_km") or 0.0

# Check AEST day boundary reset
stored_date = self.database.get_trip_state_text("daily_reset_date")
today_aest = _current_aest_date()
if stored_date != today_aest:
    self._daily_km = 0.0
    self.database.set_trip_state("daily_km", 0.0)
    self.database.set_trip_state_text("daily_reset_date", today_aest)
    log.info("daily_distance_reset", new_date=today_aest)

# Load reached waypoints
self._reached_waypoints = self.database.get_reached_waypoints()
```

**engine.py — Distance accumulation in _record_telemetry():**

After the GPS reading block (where latitude/longitude are read), add distance accumulation:

```python
if gps_reading and gps_reading.latitude is not None and gps_reading.speed_kmh is not None and gps_reading.speed_kmh >= 5.0:
    if self._last_known_lat is not None:
        delta_km = self._haversine_km(
            self._last_known_lat, self._last_known_lon,
            gps_reading.latitude, gps_reading.longitude
        )
        # Reject implausible deltas (> 1 km in 1 second = > 3600 km/h)
        if delta_km <= 1.0:
            self._odometer_km += delta_km
            self._daily_km += delta_km
    self._last_known_lat = gps_reading.latitude
    self._last_known_lon = gps_reading.longitude
```

Important: only update `_last_known_lat` when speed >= 5 km/h (moving). This prevents GPS drift at rest from corrupting the odometer. Add a sanity cap of 1 km per 1-second GPS fix (3600 km/h) to reject impossible deltas from GPS jumps.

**engine.py — Periodic persistence:**

After distance accumulation, persist every 60 seconds:
```python
now = time.monotonic()
if (now - self._last_trip_persist) >= TRIP_PERSIST_INTERVAL_S:
    self.database.set_trip_state("odometer_km", self._odometer_km)
    self.database.set_trip_state("daily_km", self._daily_km)
    self._last_trip_persist = now
```

**engine.py — Waypoint detection:**

After GPS position update (regardless of speed threshold), check waypoints:
```python
if gps_reading and gps_reading.latitude is not None:
    self._check_waypoints(gps_reading.latitude, gps_reading.longitude)
```

Add `_check_waypoints` method:
```python
def _check_waypoints(self, lat: float, lon: float) -> None:
    for i, waypoint in enumerate(self.config.route_waypoints):
        if i in self._reached_waypoints:
            continue
        dist_km = self._haversine_km(lat, lon, waypoint.lat, waypoint.lon)
        if dist_km <= 5.0:
            self._reached_waypoints.add(i)
            self.database.record_waypoint_reached(i, waypoint.name, lat, lon)
            log.info(
                "waypoint_reached",
                name=waypoint.name,
                day=waypoint.day,
                distance_km=round(dist_km, 2),
            )
```

**engine.py — get_status() extension:**

Add to the status dict returned by `get_status()`:
- `odometer_km`: `round(self._odometer_km, 1)`
- `daily_km`: `round(self._daily_km, 1)`
- `waypoints_reached`: `len(self._reached_waypoints)`
- `waypoints_total`: `len(self.config.route_waypoints)`

This makes trip data available to future subsystems (display, TTS).

**engine.py — Keep existing _distance_from_start_km:**

Do NOT remove `_distance_from_start_km` or `_distance_to_destination_km` — they are used by
`_on_event()` and `_update_overlay()`. The new odometer fields exist alongside them.
  </action>
  <verify>
    <automated>cd /Users/tgreen/dev/shitbox && python -c "from shitbox.utils.config import WaypointConfig, RouteConfig; print('Config OK')" && python -c "from shitbox.events.engine import UnifiedEngine; print('Engine OK')" && ruff check src/shitbox/utils/config.py src/shitbox/events/engine.py && pytest tests/ -x -q</automated>
  </verify>
  <done>WaypointConfig and RouteConfig dataclasses exist. config.yaml has route section. Engine accumulates distance when speed >= 5 km/h, persists every 60s, checks waypoints within 5 km, resets daily distance on AEST day boundary. Existing tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Trip tracking and waypoint detection tests</name>
  <files>
    tests/test_trip_tracking.py
  </files>
  <action>
Create `tests/test_trip_tracking.py` with comprehensive tests for STGE-01, STGE-02, STGE-03.

**Database helper tests:**

- `test_trip_state_get_set` — set_trip_state("odometer_km", 123.4), assert get_trip_state returns 123.4
- `test_trip_state_text_get_set` — set_trip_state_text("daily_reset_date", "2026-02-27"), assert get_trip_state_text returns "2026-02-27"
- `test_trip_state_upsert` — set_trip_state twice with different values, assert only latest value returned
- `test_trip_state_missing_key` — get_trip_state("nonexistent") returns None

**Waypoint persistence tests:**

- `test_record_waypoint_reached` — record waypoint 0, assert get_reached_waypoints() returns {0}
- `test_waypoint_idempotent` — record same waypoint twice, assert no error and set still has one entry
- `test_multiple_waypoints_reached` — record waypoints 0, 2, 5, assert get_reached_waypoints() returns {0, 2, 5}

**Distance accumulation tests (unit-level, testing the logic not the full engine):**

- `test_odometer_accumulates` — simulate two GPS fixes at known coordinates with speed >= 5 km/h. Use haversine to verify expected delta is added to odometer.
- `test_odometer_skips_slow` — simulate GPS fix with speed 3 km/h. Assert _last_known_lat is NOT updated and odometer does not change.
- `test_odometer_rejects_implausible_delta` — simulate GPS fixes that would produce > 1 km delta in one second. Assert delta is rejected (odometer unchanged).
- `test_odometer_persists` — mock database.set_trip_state, verify it is called with "odometer_km" after TRIP_PERSIST_INTERVAL_S elapses.

**Daily distance tests:**

- `test_daily_reset_new_day` — mock get_trip_state_text("daily_reset_date") to return yesterday's date. Assert daily_km resets to 0.0 and set_trip_state_text is called with today's date.
- `test_daily_persists_same_day` — mock get_trip_state_text("daily_reset_date") to return today's AEST date. Assert daily_km is loaded from database, not reset.

**Waypoint detection tests:**

- `test_waypoint_reached` — create a WaypointConfig at known coordinates, simulate GPS fix within 5 km. Assert record_waypoint_reached is called and waypoint index is in reached set.
- `test_waypoint_not_reached` — simulate GPS fix > 5 km from waypoint. Assert record_waypoint_reached is NOT called.
- `test_waypoint_already_reached_skipped` — pre-populate reached set with waypoint index. Assert record_waypoint_reached is NOT called again.
- `test_waypoints_loaded_on_boot` — mock get_reached_waypoints() to return {0, 2}. Assert _reached_waypoints is populated from database.
- `test_stage_label` — verify get_status() returns correct waypoints_reached count and waypoints_total count.

**AEST helper test:**

- `test_current_aest_date` — mock datetime.now(timezone.utc) to a known UTC time. Assert _current_aest_date() returns the correct AEST date (e.g., UTC 2026-02-27T23:00 = AEST 2026-02-28).

Use `unittest.mock.patch`, `patch.object`, and existing test fixtures. For engine-level tests, use minimal EngineConfig construction or mock the engine's relevant attributes directly. For database tests, use the existing `db` fixture from conftest.py (ensure the v4 migration runs).

Import `_current_aest_date` from engine module or test the logic inline if it is not importable.
  </action>
  <verify>
    <automated>cd /Users/tgreen/dev/shitbox && pytest tests/test_trip_tracking.py -x -v && pytest tests/ -x -q</automated>
  </verify>
  <done>All trip tracking tests pass. Tests cover odometer accumulation, speed threshold filtering, implausible delta rejection, daily AEST reset, waypoint detection within 5 km, waypoint idempotency, persistence across reboots, and database helpers. Full test suite passes with no regressions.</done>
</task>

</tasks>

<verification>
1. `pytest tests/test_trip_tracking.py -x -v` — all trip tracking tests pass
2. `pytest tests/ -x -q` — full suite passes with no regressions
3. `ruff check src/shitbox/utils/config.py src/shitbox/events/engine.py` — no lint errors
4. `python -c "from shitbox.utils.config import load_config; c = load_config('config/config.yaml'); print(c.sensors.gps.route)"` — config loads without error
</verification>

<success_criteria>
- Odometer accumulates distance only when speed >= 5 km/h with 1 km/s sanity cap
- Daily distance resets on AEST day boundary (first boot of new day)
- Waypoints within 5 km are detected, persisted, and idempotent
- Route waypoints load from YAML config into WaypointConfig dataclasses
- get_status() includes odometer_km, daily_km, waypoints_reached, waypoints_total
- All existing + new tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-remote-health-and-stage-tracking/04-02-SUMMARY.md`
</output>
